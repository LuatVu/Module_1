/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/RTCMultiConnection.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "../../../../../../usr/lib/node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n\n//# sourceURL=webpack:///(webpack)/buildin/global.js?");

/***/ }),

/***/ "../../../../../../usr/lib/node_modules/webpack/node_modules/process/browser.js":
/*!*************************************************!*\
  !*** (webpack)/node_modules/process/browser.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n//# sourceURL=webpack:///(webpack)/node_modules/process/browser.js?");

/***/ }),

/***/ "./src/RTCMultiConnection.js":
/*!***********************************!*\
  !*** ./src/RTCMultiConnection.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global, process) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n\n// Last time updated: 2019-02-16 7:11:13 PM UTC\n\n// _________________________\n// RTCMultiConnection v3.6.8\n\n// Open-Sourced: https://github.com/muaz-khan/RTCMultiConnection\n\n// --------------------------------------------------\n// Muaz Khan     - www.MuazKhan.com\n// MIT License   - www.WebRTC-Experiment.com/licence\n// --------------------------------------------------\n\nvar RTCMultiConnection = function(roomid, forceOptions) {\n\n    var browserFakeUserAgent = 'Fake/5.0 (FakeOS) AppleWebKit/123 (KHTML, like Gecko) Fake/12.3.4567.89 Fake/123.45';\n\n    (function(that) {\n        if (!that) {\n            return;\n        }\n\n        if (typeof window !== 'undefined') {\n            return;\n        }\n\n        if (typeof global === 'undefined') {\n            return;\n        }\n\n        global.navigator = {\n            userAgent: browserFakeUserAgent,\n            getUserMedia: function() {}\n        };\n\n        if (!global.console) {\n            global.console = {};\n        }\n\n        if (typeof global.console.debug === 'undefined') {\n            global.console.debug = global.console.info = global.console.error = global.console.log = global.console.log || function() {\n                console.log(arguments);\n            };\n        }\n\n        if (typeof document === 'undefined') {\n            /*global document:true */\n            that.document = {};\n\n            document.createElement = document.captureStream = document.mozCaptureStream = function() {\n                var obj = {\n                    getContext: function() {\n                        return obj;\n                    },\n                    play: function() {},\n                    pause: function() {},\n                    drawImage: function() {},\n                    toDataURL: function() {\n                        return '';\n                    }\n                };\n                return obj;\n            };\n\n            document.addEventListener = document.removeEventListener = that.addEventListener = that.removeEventListener = function() {};\n\n            that.HTMLVideoElement = that.HTMLMediaElement = function() {};\n        }\n\n        if (typeof io === 'undefined') {\n            that.io = function() {\n                return {\n                    on: function(eventName, callback) {\n                        callback = callback || function() {};\n\n                        if (eventName === 'connect') {\n                            callback();\n                        }\n                    },\n                    emit: function(eventName, data, callback) {\n                        callback = callback || function() {};\n                        if (eventName === 'open-room' || eventName === 'join-room') {\n                            callback(true, data.sessionid, null);\n                        }\n                    }\n                };\n            };\n        }\n\n        if (typeof location === 'undefined') {\n            /*global location:true */\n            that.location = {\n                protocol: 'file:',\n                href: '',\n                hash: '',\n                origin: 'self'\n            };\n        }\n\n        if (typeof screen === 'undefined') {\n            /*global screen:true */\n            that.screen = {\n                width: 0,\n                height: 0\n            };\n        }\n\n        if (typeof URL === 'undefined') {\n            /*global screen:true */\n            that.URL = {\n                createObjectURL: function() {\n                    return '';\n                },\n                revokeObjectURL: function() {\n                    return '';\n                }\n            };\n        }\n\n        /*global window:true */\n        that.window = global;\n    })(typeof global !== 'undefined' ? global : null);\n\n    function SocketConnection(connection, connectCallback) {\n        function isData(session) {\n            return !session.audio && !session.video && !session.screen && session.data;\n        }\n\n        var parameters = '';\n\n        parameters += '?userid=' + connection.userid;\n        parameters += '&sessionid=' + connection.sessionid;\n        parameters += '&msgEvent=' + connection.socketMessageEvent;\n        parameters += '&socketCustomEvent=' + connection.socketCustomEvent;\n        parameters += '&autoCloseEntireSession=' + !!connection.autoCloseEntireSession;\n\n        if (connection.session.broadcast === true) {\n            parameters += '&oneToMany=true';\n        }\n\n        parameters += '&maxParticipantsAllowed=' + connection.maxParticipantsAllowed;\n\n        if (connection.enableScalableBroadcast) {\n            parameters += '&enableScalableBroadcast=true';\n            parameters += '&maxRelayLimitPerUser=' + (connection.maxRelayLimitPerUser || 2);\n        }\n\n        parameters += '&extra=' + JSON.stringify(connection.extra || {});\n\n        if (connection.socketCustomParameters) {\n            parameters += connection.socketCustomParameters;\n        }\n\n        try {\n            io.sockets = {};\n        } catch (e) {};\n\n        if (!connection.socketURL) {\n            connection.socketURL = '/';\n        }\n\n        if (connection.socketURL.substr(connection.socketURL.length - 1, 1) != '/') {\n            // connection.socketURL = 'https://domain.com:9001/';\n            throw '\"socketURL\" MUST end with a slash.';\n        }\n\n        if (connection.enableLogs) {\n            if (connection.socketURL == '/') {\n                console.info('socket.io url is: ', location.origin + '/');\n            } else {\n                console.info('socket.io url is: ', connection.socketURL);\n            }\n        }\n\n        try {\n            connection.socket = io(connection.socketURL + parameters);\n        } catch (e) {\n            connection.socket = io.connect(connection.socketURL + parameters, connection.socketOptions);\n        }\n\n        var mPeer = connection.multiPeersHandler;\n\n        connection.socket.on('extra-data-updated', function(remoteUserId, extra) {\n            if (!connection.peers[remoteUserId]) return;\n            connection.peers[remoteUserId].extra = extra;\n\n            connection.onExtraDataUpdated({\n                userid: remoteUserId,\n                extra: extra\n            });\n\n            updateExtraBackup(remoteUserId, extra);\n        });\n\n        function updateExtraBackup(remoteUserId, extra) {\n            if (!connection.peersBackup[remoteUserId]) {\n                connection.peersBackup[remoteUserId] = {\n                    userid: remoteUserId,\n                    extra: {}\n                };\n            }\n\n            connection.peersBackup[remoteUserId].extra = extra;\n        }\n\n        function onMessageEvent(message) {\n            if (message.remoteUserId != connection.userid) return;\n\n            if (connection.peers[message.sender] && connection.peers[message.sender].extra != message.message.extra) {\n                connection.peers[message.sender].extra = message.extra;\n                connection.onExtraDataUpdated({\n                    userid: message.sender,\n                    extra: message.extra\n                });\n\n                updateExtraBackup(message.sender, message.extra);\n            }\n\n            if (message.message.streamSyncNeeded && connection.peers[message.sender]) {\n                var stream = connection.streamEvents[message.message.streamid];\n                if (!stream || !stream.stream) {\n                    return;\n                }\n\n                var action = message.message.action;\n\n                if (action === 'ended' || action === 'inactive' || action === 'stream-removed') {\n                    if (connection.peersBackup[stream.userid]) {\n                        stream.extra = connection.peersBackup[stream.userid].extra;\n                    }\n                    connection.onstreamended(stream);\n                    return;\n                }\n\n                var type = message.message.type != 'both' ? message.message.type : null;\n\n                if (typeof stream.stream[action] == 'function') {\n                    stream.stream[action](type);\n                }\n                return;\n            }\n\n            if (message.message === 'dropPeerConnection') {\n                connection.deletePeer(message.sender);\n                return;\n            }\n\n            if (message.message.allParticipants) {\n                if (message.message.allParticipants.indexOf(message.sender) === -1) {\n                    message.message.allParticipants.push(message.sender);\n                }\n\n                message.message.allParticipants.forEach(function(participant) {\n                    mPeer[!connection.peers[participant] ? 'createNewPeer' : 'renegotiatePeer'](participant, {\n                        localPeerSdpConstraints: {\n                            OfferToReceiveAudio: connection.sdpConstraints.mandatory.OfferToReceiveAudio,\n                            OfferToReceiveVideo: connection.sdpConstraints.mandatory.OfferToReceiveVideo\n                        },\n                        remotePeerSdpConstraints: {\n                            OfferToReceiveAudio: connection.session.oneway ? !!connection.session.audio : connection.sdpConstraints.mandatory.OfferToReceiveAudio,\n                            OfferToReceiveVideo: connection.session.oneway ? !!connection.session.video || !!connection.session.screen : connection.sdpConstraints.mandatory.OfferToReceiveVideo\n                        },\n                        isOneWay: !!connection.session.oneway || connection.direction === 'one-way',\n                        isDataOnly: isData(connection.session)\n                    });\n                });\n                return;\n            }\n\n            if (message.message.newParticipant) {\n                if (message.message.newParticipant == connection.userid) return;\n                if (!!connection.peers[message.message.newParticipant]) return;\n\n                mPeer.createNewPeer(message.message.newParticipant, message.message.userPreferences || {\n                    localPeerSdpConstraints: {\n                        OfferToReceiveAudio: connection.sdpConstraints.mandatory.OfferToReceiveAudio,\n                        OfferToReceiveVideo: connection.sdpConstraints.mandatory.OfferToReceiveVideo\n                    },\n                    remotePeerSdpConstraints: {\n                        OfferToReceiveAudio: connection.session.oneway ? !!connection.session.audio : connection.sdpConstraints.mandatory.OfferToReceiveAudio,\n                        OfferToReceiveVideo: connection.session.oneway ? !!connection.session.video || !!connection.session.screen : connection.sdpConstraints.mandatory.OfferToReceiveVideo\n                    },\n                    isOneWay: !!connection.session.oneway || connection.direction === 'one-way',\n                    isDataOnly: isData(connection.session)\n                });\n                return;\n            }\n\n            if (message.message.readyForOffer) {\n                if (connection.attachStreams.length) {\n                    connection.waitingForLocalMedia = false;\n                }\n\n                if (connection.waitingForLocalMedia) {\n                    // if someone is waiting to join you\n                    // make sure that we've local media before making a handshake\n                    setTimeout(function() {\n                        onMessageEvent(message);\n                    }, 1);\n                    return;\n                }\n            }\n\n            if (message.message.newParticipationRequest && message.sender !== connection.userid) {\n                if (connection.peers[message.sender]) {\n                    connection.deletePeer(message.sender);\n                }\n\n                var userPreferences = {\n                    extra: message.extra || {},\n                    localPeerSdpConstraints: message.message.remotePeerSdpConstraints || {\n                        OfferToReceiveAudio: connection.sdpConstraints.mandatory.OfferToReceiveAudio,\n                        OfferToReceiveVideo: connection.sdpConstraints.mandatory.OfferToReceiveVideo\n                    },\n                    remotePeerSdpConstraints: message.message.localPeerSdpConstraints || {\n                        OfferToReceiveAudio: connection.session.oneway ? !!connection.session.audio : connection.sdpConstraints.mandatory.OfferToReceiveAudio,\n                        OfferToReceiveVideo: connection.session.oneway ? !!connection.session.video || !!connection.session.screen : connection.sdpConstraints.mandatory.OfferToReceiveVideo\n                    },\n                    isOneWay: typeof message.message.isOneWay !== 'undefined' ? message.message.isOneWay : !!connection.session.oneway || connection.direction === 'one-way',\n                    isDataOnly: typeof message.message.isDataOnly !== 'undefined' ? message.message.isDataOnly : isData(connection.session),\n                    dontGetRemoteStream: typeof message.message.isOneWay !== 'undefined' ? message.message.isOneWay : !!connection.session.oneway || connection.direction === 'one-way',\n                    dontAttachLocalStream: !!message.message.dontGetRemoteStream,\n                    connectionDescription: message,\n                    successCallback: function() {}\n                };\n\n                connection.onNewParticipant(message.sender, userPreferences);\n                return;\n            }\n\n            if (message.message.changedUUID) {\n                if (connection.peers[message.message.oldUUID]) {\n                    connection.peers[message.message.newUUID] = connection.peers[message.message.oldUUID];\n                    delete connection.peers[message.message.oldUUID];\n                }\n            }\n\n            if (message.message.userLeft) {\n                mPeer.onUserLeft(message.sender);\n\n                if (!!message.message.autoCloseEntireSession) {\n                    connection.leave();\n                }\n\n                return;\n            }\n\n            mPeer.addNegotiatedMessage(message.message, message.sender);\n        }\n\n        connection.socket.on(connection.socketMessageEvent, onMessageEvent);\n\n        var alreadyConnected = false;\n\n        connection.socket.resetProps = function() {\n            alreadyConnected = false;\n        };\n\n        connection.socket.on('connect', function() {\n            if (alreadyConnected) {\n                return;\n            }\n            alreadyConnected = true;\n\n            if (connection.enableLogs) {\n                console.info('socket.io connection is opened.');\n            }\n\n            setTimeout(function() {\n                connection.socket.emit('extra-data-updated', connection.extra);\n            }, 1000);\n\n            if (connectCallback) {\n                connectCallback(connection.socket);\n            }\n        });\n\n        connection.socket.on('disconnect', function(event) {\n            connection.onSocketDisconnect(event);\n        });\n\n        connection.socket.on('error', function(event) {\n            connection.onSocketError(event);\n        });\n\n        connection.socket.on('user-disconnected', function(remoteUserId) {\n            if (remoteUserId === connection.userid) {\n                return;\n            }\n\n            connection.onUserStatusChanged({\n                userid: remoteUserId,\n                status: 'offline',\n                extra: connection.peers[remoteUserId] ? connection.peers[remoteUserId].extra || {} : {}\n            });\n\n            connection.deletePeer(remoteUserId);\n        });\n\n        connection.socket.on('user-connected', function(userid) {\n            if (userid === connection.userid) {\n                return;\n            }\n\n            connection.onUserStatusChanged({\n                userid: userid,\n                status: 'online',\n                extra: connection.peers[userid] ? connection.peers[userid].extra || {} : {}\n            });\n        });\n\n        connection.socket.on('closed-entire-session', function(sessionid, extra) {\n            connection.leave();\n            connection.onEntireSessionClosed({\n                sessionid: sessionid,\n                userid: sessionid,\n                extra: extra\n            });\n        });\n\n        connection.socket.on('userid-already-taken', function(useridAlreadyTaken, yourNewUserId) {\n            connection.onUserIdAlreadyTaken(useridAlreadyTaken, yourNewUserId);\n        });\n\n        connection.socket.on('logs', function(log) {\n            if (!connection.enableLogs) return;\n            console.debug('server-logs', log);\n        });\n\n        connection.socket.on('number-of-broadcast-viewers-updated', function(data) {\n            connection.onNumberOfBroadcastViewersUpdated(data);\n        });\n\n        connection.socket.on('set-isInitiator-true', function(sessionid) {\n            if (sessionid != connection.sessionid) return;\n            connection.isInitiator = true;\n        });\n    }\n\n    function MultiPeers(connection) {\n        var self = this;\n\n        var skipPeers = ['getAllParticipants', 'getLength', 'selectFirst', 'streams', 'send', 'forEach'];\n        connection.peers = {\n            getLength: function() {\n                var numberOfPeers = 0;\n                for (var peer in this) {\n                    if (skipPeers.indexOf(peer) == -1) {\n                        numberOfPeers++;\n                    }\n                }\n                return numberOfPeers;\n            },\n            selectFirst: function() {\n                var firstPeer;\n                for (var peer in this) {\n                    if (skipPeers.indexOf(peer) == -1) {\n                        firstPeer = this[peer];\n                    }\n                }\n                return firstPeer;\n            },\n            getAllParticipants: function(sender) {\n                var allPeers = [];\n                for (var peer in this) {\n                    if (skipPeers.indexOf(peer) == -1 && peer != sender) {\n                        allPeers.push(peer);\n                    }\n                }\n                return allPeers;\n            },\n            forEach: function(callbcak) {\n                this.getAllParticipants().forEach(function(participant) {\n                    callbcak(connection.peers[participant]);\n                });\n            },\n            send: function(data, remoteUserId) {\n                var that = this;\n\n                if (!isNull(data.size) && !isNull(data.type)) {\n                    if (connection.enableFileSharing) {\n                        self.shareFile(data, remoteUserId);\n                        return;\n                    }\n\n                    if (typeof data !== 'string') {\n                        data = JSON.stringify(data);\n                    }\n                }\n\n                if (data.type !== 'text' && !(data instanceof ArrayBuffer) && !(data instanceof DataView)) {\n                    TextSender.send({\n                        text: data,\n                        channel: this,\n                        connection: connection,\n                        remoteUserId: remoteUserId\n                    });\n                    return;\n                }\n\n                if (data.type === 'text') {\n                    data = JSON.stringify(data);\n                }\n\n                if (remoteUserId) {\n                    var remoteUser = connection.peers[remoteUserId];\n                    if (remoteUser) {\n                        if (!remoteUser.channels.length) {\n                            connection.peers[remoteUserId].createDataChannel();\n                            connection.renegotiate(remoteUserId);\n                            setTimeout(function() {\n                                that.send(data, remoteUserId);\n                            }, 3000);\n                            return;\n                        }\n\n                        remoteUser.channels.forEach(function(channel) {\n                            channel.send(data);\n                        });\n                        return;\n                    }\n                }\n\n                this.getAllParticipants().forEach(function(participant) {\n                    if (!that[participant].channels.length) {\n                        connection.peers[participant].createDataChannel();\n                        connection.renegotiate(participant);\n                        setTimeout(function() {\n                            that[participant].channels.forEach(function(channel) {\n                                channel.send(data);\n                            });\n                        }, 3000);\n                        return;\n                    }\n\n                    that[participant].channels.forEach(function(channel) {\n                        channel.send(data);\n                    });\n                });\n            }\n        };\n\n        this.uuid = connection.userid;\n\n        this.getLocalConfig = function(remoteSdp, remoteUserId, userPreferences) {\n            if (!userPreferences) {\n                userPreferences = {};\n            }\n\n            return {\n                streamsToShare: userPreferences.streamsToShare || {},\n                rtcMultiConnection: connection,\n                connectionDescription: userPreferences.connectionDescription,\n                userid: remoteUserId,\n                localPeerSdpConstraints: userPreferences.localPeerSdpConstraints,\n                remotePeerSdpConstraints: userPreferences.remotePeerSdpConstraints,\n                dontGetRemoteStream: !!userPreferences.dontGetRemoteStream,\n                dontAttachLocalStream: !!userPreferences.dontAttachLocalStream,\n                renegotiatingPeer: !!userPreferences.renegotiatingPeer,\n                peerRef: userPreferences.peerRef,\n                channels: userPreferences.channels || [],\n                onLocalSdp: function(localSdp) {\n                    self.onNegotiationNeeded(localSdp, remoteUserId);\n                },\n                onLocalCandidate: function(localCandidate) {\n                    localCandidate = OnIceCandidateHandler.processCandidates(connection, localCandidate)\n                    if (localCandidate) {\n                        self.onNegotiationNeeded(localCandidate, remoteUserId);\n                    }\n                },\n                remoteSdp: remoteSdp,\n                onDataChannelMessage: function(message) {\n                    if (!connection.fbr && connection.enableFileSharing) initFileBufferReader();\n\n                    if (typeof message == 'string' || !connection.enableFileSharing) {\n                        self.onDataChannelMessage(message, remoteUserId);\n                        return;\n                    }\n\n                    var that = this;\n\n                    if (message instanceof ArrayBuffer || message instanceof DataView) {\n                        connection.fbr.convertToObject(message, function(object) {\n                            that.onDataChannelMessage(object);\n                        });\n                        return;\n                    }\n\n                    if (message.readyForNextChunk) {\n                        connection.fbr.getNextChunk(message, function(nextChunk, isLastChunk) {\n                            connection.peers[remoteUserId].channels.forEach(function(channel) {\n                                channel.send(nextChunk);\n                            });\n                        }, remoteUserId);\n                        return;\n                    }\n\n                    if (message.chunkMissing) {\n                        connection.fbr.chunkMissing(message);\n                        return;\n                    }\n\n                    connection.fbr.addChunk(message, function(promptNextChunk) {\n                        connection.peers[remoteUserId].peer.channel.send(promptNextChunk);\n                    });\n                },\n                onDataChannelError: function(error) {\n                    self.onDataChannelError(error, remoteUserId);\n                },\n                onDataChannelOpened: function(channel) {\n                    self.onDataChannelOpened(channel, remoteUserId);\n                },\n                onDataChannelClosed: function(event) {\n                    self.onDataChannelClosed(event, remoteUserId);\n                },\n                onRemoteStream: function(stream) {\n                    if (connection.peers[remoteUserId]) {\n                        connection.peers[remoteUserId].streams.push(stream);\n                    }\n\n                    self.onGettingRemoteMedia(stream, remoteUserId);\n                },\n                onRemoteStreamRemoved: function(stream) {\n                    self.onRemovingRemoteMedia(stream, remoteUserId);\n                },\n                onPeerStateChanged: function(states) {\n                    self.onPeerStateChanged(states);\n\n                    if (states.iceConnectionState === 'new') {\n                        self.onNegotiationStarted(remoteUserId, states);\n                    }\n\n                    if (states.iceConnectionState === 'connected') {\n                        self.onNegotiationCompleted(remoteUserId, states);\n                    }\n\n                    if (states.iceConnectionState.search(/closed|failed/gi) !== -1) {\n                        self.onUserLeft(remoteUserId);\n                        self.disconnectWith(remoteUserId);\n                    }\n                }\n            };\n        };\n\n        this.createNewPeer = function(remoteUserId, userPreferences) {\n            if (connection.maxParticipantsAllowed <= connection.getAllParticipants().length) {\n                return;\n            }\n\n            userPreferences = userPreferences || {};\n\n            if (connection.isInitiator && !!connection.session.audio && connection.session.audio === 'two-way' && !userPreferences.streamsToShare) {\n                userPreferences.isOneWay = false;\n                userPreferences.isDataOnly = false;\n                userPreferences.session = connection.session;\n            }\n\n            if (!userPreferences.isOneWay && !userPreferences.isDataOnly) {\n                userPreferences.isOneWay = true;\n                this.onNegotiationNeeded({\n                    enableMedia: true,\n                    userPreferences: userPreferences\n                }, remoteUserId);\n                return;\n            }\n\n            userPreferences = connection.setUserPreferences(userPreferences, remoteUserId);\n            var localConfig = this.getLocalConfig(null, remoteUserId, userPreferences);\n            connection.peers[remoteUserId] = new PeerInitiator(localConfig);\n        };\n\n        this.createAnsweringPeer = function(remoteSdp, remoteUserId, userPreferences) {\n            userPreferences = connection.setUserPreferences(userPreferences || {}, remoteUserId);\n\n            var localConfig = this.getLocalConfig(remoteSdp, remoteUserId, userPreferences);\n            connection.peers[remoteUserId] = new PeerInitiator(localConfig);\n        };\n\n        this.renegotiatePeer = function(remoteUserId, userPreferences, remoteSdp) {\n            if (!connection.peers[remoteUserId]) {\n                if (connection.enableLogs) {\n                    console.error('Peer (' + remoteUserId + ') does not exist. Renegotiation skipped.');\n                }\n                return;\n            }\n\n            if (!userPreferences) {\n                userPreferences = {};\n            }\n\n            userPreferences.renegotiatingPeer = true;\n            userPreferences.peerRef = connection.peers[remoteUserId].peer;\n            userPreferences.channels = connection.peers[remoteUserId].channels;\n\n            var localConfig = this.getLocalConfig(remoteSdp, remoteUserId, userPreferences);\n\n            connection.peers[remoteUserId] = new PeerInitiator(localConfig);\n        };\n\n        this.replaceTrack = function(track, remoteUserId, isVideoTrack) {\n            if (!connection.peers[remoteUserId]) {\n                throw 'This peer (' + remoteUserId + ') does not exist.';\n            }\n\n            var peer = connection.peers[remoteUserId].peer;\n\n            if (!!peer.getSenders && typeof peer.getSenders === 'function' && peer.getSenders().length) {\n                peer.getSenders().forEach(function(rtpSender) {\n                    if (isVideoTrack && rtpSender.track.kind === 'video') {\n                        connection.peers[remoteUserId].peer.lastVideoTrack = rtpSender.track;\n                        rtpSender.replaceTrack(track);\n                    }\n\n                    if (!isVideoTrack && rtpSender.track.kind === 'audio') {\n                        connection.peers[remoteUserId].peer.lastAudioTrack = rtpSender.track;\n                        rtpSender.replaceTrack(track);\n                    }\n                });\n                return;\n            }\n\n            console.warn('RTPSender.replaceTrack is NOT supported.');\n            this.renegotiatePeer(remoteUserId);\n        };\n\n        this.onNegotiationNeeded = function(message, remoteUserId) {};\n        this.addNegotiatedMessage = function(message, remoteUserId) {\n            if (message.type && message.sdp) {\n                if (message.type == 'answer') {\n                    if (connection.peers[remoteUserId]) {\n                        connection.peers[remoteUserId].addRemoteSdp(message);\n                    }\n                }\n\n                if (message.type == 'offer') {\n                    if (message.renegotiatingPeer) {\n                        this.renegotiatePeer(remoteUserId, null, message);\n                    } else {\n                        this.createAnsweringPeer(message, remoteUserId);\n                    }\n                }\n\n                if (connection.enableLogs) {\n                    console.log('Remote peer\\'s sdp:', message.sdp);\n                }\n                return;\n            }\n\n            if (message.candidate) {\n                if (connection.peers[remoteUserId]) {\n                    connection.peers[remoteUserId].addRemoteCandidate(message);\n                }\n\n                if (connection.enableLogs) {\n                    console.log('Remote peer\\'s candidate pairs:', message.candidate);\n                }\n                return;\n            }\n\n            if (message.enableMedia) {\n                connection.session = message.userPreferences.session || connection.session;\n\n                if (connection.session.oneway && connection.attachStreams.length) {\n                    connection.attachStreams = [];\n                }\n\n                if (message.userPreferences.isDataOnly && connection.attachStreams.length) {\n                    connection.attachStreams.length = [];\n                }\n\n                var streamsToShare = {};\n                connection.attachStreams.forEach(function(stream) {\n                    streamsToShare[stream.streamid] = {\n                        isAudio: !!stream.isAudio,\n                        isVideo: !!stream.isVideo,\n                        isScreen: !!stream.isScreen\n                    };\n                });\n                message.userPreferences.streamsToShare = streamsToShare;\n\n                self.onNegotiationNeeded({\n                    readyForOffer: true,\n                    userPreferences: message.userPreferences\n                }, remoteUserId);\n            }\n\n            if (message.readyForOffer) {\n                connection.onReadyForOffer(remoteUserId, message.userPreferences);\n            }\n\n            function cb(stream) {\n                gumCallback(stream, message, remoteUserId);\n            }\n        };\n\n        function gumCallback(stream, message, remoteUserId) {\n            var streamsToShare = {};\n            connection.attachStreams.forEach(function(stream) {\n                streamsToShare[stream.streamid] = {\n                    isAudio: !!stream.isAudio,\n                    isVideo: !!stream.isVideo,\n                    isScreen: !!stream.isScreen\n                };\n            });\n            message.userPreferences.streamsToShare = streamsToShare;\n\n            self.onNegotiationNeeded({\n                readyForOffer: true,\n                userPreferences: message.userPreferences\n            }, remoteUserId);\n        }\n\n        this.onGettingRemoteMedia = function(stream, remoteUserId) {};\n        this.onRemovingRemoteMedia = function(stream, remoteUserId) {};\n        this.onGettingLocalMedia = function(localStream) {};\n        this.onLocalMediaError = function(error, constraints) {\n            connection.onMediaError(error, constraints);\n        };\n\n        function initFileBufferReader() {\n            connection.fbr = new FileBufferReader();\n            connection.fbr.onProgress = function(chunk) {\n                connection.onFileProgress(chunk);\n            };\n            connection.fbr.onBegin = function(file) {\n                connection.onFileStart(file);\n            };\n            connection.fbr.onEnd = function(file) {\n                connection.onFileEnd(file);\n            };\n        }\n\n        this.shareFile = function(file, remoteUserId) {\n            initFileBufferReader();\n\n            connection.fbr.readAsArrayBuffer(file, function(uuid) {\n                var arrayOfUsers = connection.getAllParticipants();\n\n                if (remoteUserId) {\n                    arrayOfUsers = [remoteUserId];\n                }\n\n                arrayOfUsers.forEach(function(participant) {\n                    connection.fbr.getNextChunk(uuid, function(nextChunk) {\n                        connection.peers[participant].channels.forEach(function(channel) {\n                            channel.send(nextChunk);\n                        });\n                    }, participant);\n                });\n            }, {\n                userid: connection.userid,\n                // extra: connection.extra,\n                chunkSize: DetectRTC.browser.name === 'Firefox' ? 15 * 1000 : connection.chunkSize || 0\n            });\n        };\n\n        if (true) {\n            var textReceiver = new TextReceiver(connection);\n        }\n\n        this.onDataChannelMessage = function(message, remoteUserId) {\n            textReceiver.receive(JSON.parse(message), remoteUserId, connection.peers[remoteUserId] ? connection.peers[remoteUserId].extra : {});\n        };\n\n        this.onDataChannelClosed = function(event, remoteUserId) {\n            event.userid = remoteUserId;\n            event.extra = connection.peers[remoteUserId] ? connection.peers[remoteUserId].extra : {};\n            connection.onclose(event);\n        };\n\n        this.onDataChannelError = function(error, remoteUserId) {\n            error.userid = remoteUserId;\n            event.extra = connection.peers[remoteUserId] ? connection.peers[remoteUserId].extra : {};\n            connection.onerror(error);\n        };\n\n        this.onDataChannelOpened = function(channel, remoteUserId) {\n            // keep last channel only; we are not expecting parallel/channels channels\n            if (connection.peers[remoteUserId].channels.length) {\n                connection.peers[remoteUserId].channels = [channel];\n                return;\n            }\n\n            connection.peers[remoteUserId].channels.push(channel);\n            connection.onopen({\n                userid: remoteUserId,\n                extra: connection.peers[remoteUserId] ? connection.peers[remoteUserId].extra : {},\n                channel: channel\n            });\n        };\n\n        this.onPeerStateChanged = function(state) {\n            connection.onPeerStateChanged(state);\n        };\n\n        this.onNegotiationStarted = function(remoteUserId, states) {};\n        this.onNegotiationCompleted = function(remoteUserId, states) {};\n\n        this.getRemoteStreams = function(remoteUserId) {\n            remoteUserId = remoteUserId || connection.peers.getAllParticipants()[0];\n            return connection.peers[remoteUserId] ? connection.peers[remoteUserId].streams : [];\n        };\n    }\n\n    'use strict';\n\n    // Last Updated On: 2019-01-10 5:32:55 AM UTC\n\n    // ________________\n    // DetectRTC v1.3.9\n\n    // Open-Sourced: https://github.com/muaz-khan/DetectRTC\n\n    // --------------------------------------------------\n    // Muaz Khan     - www.MuazKhan.com\n    // MIT License   - www.WebRTC-Experiment.com/licence\n    // --------------------------------------------------\n\n    (function() {\n\n        var browserFakeUserAgent = 'Fake/5.0 (FakeOS) AppleWebKit/123 (KHTML, like Gecko) Fake/12.3.4567.89 Fake/123.45';\n\n        var isNodejs = typeof process === 'object' && typeof process.versions === 'object' && process.versions.node && /*node-process*/ !process.browser;\n        if (isNodejs) {\n            var version = process.versions.node.toString().replace('v', '');\n            browserFakeUserAgent = 'Nodejs/' + version + ' (NodeOS) AppleWebKit/' + version + ' (KHTML, like Gecko) Nodejs/' + version + ' Nodejs/' + version\n        }\n\n        (function(that) {\n            if (typeof window !== 'undefined') {\n                return;\n            }\n\n            if (typeof window === 'undefined' && typeof global !== 'undefined') {\n                global.navigator = {\n                    userAgent: browserFakeUserAgent,\n                    getUserMedia: function() {}\n                };\n\n                /*global window:true */\n                that.window = global;\n            } else if (typeof window === 'undefined') {\n                // window = this;\n            }\n\n            if (typeof location === 'undefined') {\n                /*global location:true */\n                that.location = {\n                    protocol: 'file:',\n                    href: '',\n                    hash: ''\n                };\n            }\n\n            if (typeof screen === 'undefined') {\n                /*global screen:true */\n                that.screen = {\n                    width: 0,\n                    height: 0\n                };\n            }\n        })(typeof global !== 'undefined' ? global : window);\n\n        /*global navigator:true */\n        var navigator = window.navigator;\n\n        if (typeof navigator !== 'undefined') {\n            if (typeof navigator.webkitGetUserMedia !== 'undefined') {\n                navigator.getUserMedia = navigator.webkitGetUserMedia;\n            }\n\n            if (typeof navigator.mozGetUserMedia !== 'undefined') {\n                navigator.getUserMedia = navigator.mozGetUserMedia;\n            }\n        } else {\n            navigator = {\n                getUserMedia: function() {},\n                userAgent: browserFakeUserAgent\n            };\n        }\n\n        var isMobileDevice = !!(/Android|webOS|iPhone|iPad|iPod|BB10|BlackBerry|IEMobile|Opera Mini|Mobile|mobile/i.test(navigator.userAgent || ''));\n\n        var isEdge = navigator.userAgent.indexOf('Edge') !== -1 && (!!navigator.msSaveOrOpenBlob || !!navigator.msSaveBlob);\n\n        var isOpera = !!window.opera || navigator.userAgent.indexOf(' OPR/') >= 0;\n        var isFirefox = typeof window.InstallTrigger !== 'undefined';\n        var isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);\n        var isChrome = !!window.chrome && !isOpera;\n        var isIE = typeof document !== 'undefined' && !!document.documentMode && !isEdge;\n\n        // this one can also be used:\n        // https://www.websocket.org/js/stuff.js (DetectBrowser.js)\n\n        function getBrowserInfo() {\n            var nVer = navigator.appVersion;\n            var nAgt = navigator.userAgent;\n            var browserName = navigator.appName;\n            var fullVersion = '' + parseFloat(navigator.appVersion);\n            var majorVersion = parseInt(navigator.appVersion, 10);\n            var nameOffset, verOffset, ix;\n\n            // both and safri and chrome has same userAgent\n            if (isSafari && !isChrome && nAgt.indexOf('CriOS') !== -1) {\n                isSafari = false;\n                isChrome = true;\n            }\n\n            // In Opera, the true version is after 'Opera' or after 'Version'\n            if (isOpera) {\n                browserName = 'Opera';\n                try {\n                    fullVersion = navigator.userAgent.split('OPR/')[1].split(' ')[0];\n                    majorVersion = fullVersion.split('.')[0];\n                } catch (e) {\n                    fullVersion = '0.0.0.0';\n                    majorVersion = 0;\n                }\n            }\n            // In MSIE version <=10, the true version is after 'MSIE' in userAgent\n            // In IE 11, look for the string after 'rv:'\n            else if (isIE) {\n                verOffset = nAgt.indexOf('rv:');\n                if (verOffset > 0) { //IE 11\n                    fullVersion = nAgt.substring(verOffset + 3);\n                } else { //IE 10 or earlier\n                    verOffset = nAgt.indexOf('MSIE');\n                    fullVersion = nAgt.substring(verOffset + 5);\n                }\n                browserName = 'IE';\n            }\n            // In Chrome, the true version is after 'Chrome' \n            else if (isChrome) {\n                verOffset = nAgt.indexOf('Chrome');\n                browserName = 'Chrome';\n                fullVersion = nAgt.substring(verOffset + 7);\n            }\n            // In Safari, the true version is after 'Safari' or after 'Version' \n            else if (isSafari) {\n                verOffset = nAgt.indexOf('Safari');\n\n                browserName = 'Safari';\n                fullVersion = nAgt.substring(verOffset + 7);\n\n                if ((verOffset = nAgt.indexOf('Version')) !== -1) {\n                    fullVersion = nAgt.substring(verOffset + 8);\n                }\n\n                if (navigator.userAgent.indexOf('Version/') !== -1) {\n                    fullVersion = navigator.userAgent.split('Version/')[1].split(' ')[0];\n                }\n            }\n            // In Firefox, the true version is after 'Firefox' \n            else if (isFirefox) {\n                verOffset = nAgt.indexOf('Firefox');\n                browserName = 'Firefox';\n                fullVersion = nAgt.substring(verOffset + 8);\n            }\n\n            // In most other browsers, 'name/version' is at the end of userAgent \n            else if ((nameOffset = nAgt.lastIndexOf(' ') + 1) < (verOffset = nAgt.lastIndexOf('/'))) {\n                browserName = nAgt.substring(nameOffset, verOffset);\n                fullVersion = nAgt.substring(verOffset + 1);\n\n                if (browserName.toLowerCase() === browserName.toUpperCase()) {\n                    browserName = navigator.appName;\n                }\n            }\n\n            if (isEdge) {\n                browserName = 'Edge';\n                fullVersion = navigator.userAgent.split('Edge/')[1];\n                // fullVersion = parseInt(navigator.userAgent.match(/Edge\\/(\\d+).(\\d+)$/)[2], 10).toString();\n            }\n\n            // trim the fullVersion string at semicolon/space/bracket if present\n            if ((ix = fullVersion.search(/[; \\)]/)) !== -1) {\n                fullVersion = fullVersion.substring(0, ix);\n            }\n\n            majorVersion = parseInt('' + fullVersion, 10);\n\n            if (isNaN(majorVersion)) {\n                fullVersion = '' + parseFloat(navigator.appVersion);\n                majorVersion = parseInt(navigator.appVersion, 10);\n            }\n\n            return {\n                fullVersion: fullVersion,\n                version: majorVersion,\n                name: browserName,\n                isPrivateBrowsing: false\n            };\n        }\n\n        // via: https://gist.github.com/cou929/7973956\n\n        function retry(isDone, next) {\n            var currentTrial = 0,\n                maxRetry = 50,\n                interval = 10,\n                isTimeout = false;\n            var id = window.setInterval(\n                function() {\n                    if (isDone()) {\n                        window.clearInterval(id);\n                        next(isTimeout);\n                    }\n                    if (currentTrial++ > maxRetry) {\n                        window.clearInterval(id);\n                        isTimeout = true;\n                        next(isTimeout);\n                    }\n                },\n                10\n            );\n        }\n\n        function isIE10OrLater(userAgent) {\n            var ua = userAgent.toLowerCase();\n            if (ua.indexOf('msie') === 0 && ua.indexOf('trident') === 0) {\n                return false;\n            }\n            var match = /(?:msie|rv:)\\s?([\\d\\.]+)/.exec(ua);\n            if (match && parseInt(match[1], 10) >= 10) {\n                return true;\n            }\n            return false;\n        }\n\n        function detectPrivateMode(callback) {\n            var isPrivate;\n\n            try {\n\n                if (window.webkitRequestFileSystem) {\n                    window.webkitRequestFileSystem(\n                        window.TEMPORARY, 1,\n                        function() {\n                            isPrivate = false;\n                        },\n                        function(e) {\n                            isPrivate = true;\n                        }\n                    );\n                } else if (window.indexedDB && /Firefox/.test(window.navigator.userAgent)) {\n                    var db;\n                    try {\n                        db = window.indexedDB.open('test');\n                        db.onerror = function() {\n                            return true;\n                        };\n                    } catch (e) {\n                        isPrivate = true;\n                    }\n\n                    if (typeof isPrivate === 'undefined') {\n                        retry(\n                            function isDone() {\n                                return db.readyState === 'done' ? true : false;\n                            },\n                            function next(isTimeout) {\n                                if (!isTimeout) {\n                                    isPrivate = db.result ? false : true;\n                                }\n                            }\n                        );\n                    }\n                } else if (isIE10OrLater(window.navigator.userAgent)) {\n                    isPrivate = false;\n                    try {\n                        if (!window.indexedDB) {\n                            isPrivate = true;\n                        }\n                    } catch (e) {\n                        isPrivate = true;\n                    }\n                } else if (window.localStorage && /Safari/.test(window.navigator.userAgent)) {\n                    try {\n                        window.localStorage.setItem('test', 1);\n                    } catch (e) {\n                        isPrivate = true;\n                    }\n\n                    if (typeof isPrivate === 'undefined') {\n                        isPrivate = false;\n                        window.localStorage.removeItem('test');\n                    }\n                }\n\n            } catch (e) {\n                isPrivate = false;\n            }\n\n            retry(\n                function isDone() {\n                    return typeof isPrivate !== 'undefined' ? true : false;\n                },\n                function next(isTimeout) {\n                    callback(isPrivate);\n                }\n            );\n        }\n\n        var isMobile = {\n            Android: function() {\n                return navigator.userAgent.match(/Android/i);\n            },\n            BlackBerry: function() {\n                return navigator.userAgent.match(/BlackBerry|BB10/i);\n            },\n            iOS: function() {\n                return navigator.userAgent.match(/iPhone|iPad|iPod/i);\n            },\n            Opera: function() {\n                return navigator.userAgent.match(/Opera Mini/i);\n            },\n            Windows: function() {\n                return navigator.userAgent.match(/IEMobile/i);\n            },\n            any: function() {\n                return (isMobile.Android() || isMobile.BlackBerry() || isMobile.iOS() || isMobile.Opera() || isMobile.Windows());\n            },\n            getOsName: function() {\n                var osName = 'Unknown OS';\n                if (isMobile.Android()) {\n                    osName = 'Android';\n                }\n\n                if (isMobile.BlackBerry()) {\n                    osName = 'BlackBerry';\n                }\n\n                if (isMobile.iOS()) {\n                    osName = 'iOS';\n                }\n\n                if (isMobile.Opera()) {\n                    osName = 'Opera Mini';\n                }\n\n                if (isMobile.Windows()) {\n                    osName = 'Windows';\n                }\n\n                return osName;\n            }\n        };\n\n        // via: http://jsfiddle.net/ChristianL/AVyND/\n        function detectDesktopOS() {\n            var unknown = '-';\n\n            var nVer = navigator.appVersion;\n            var nAgt = navigator.userAgent;\n\n            var os = unknown;\n            var clientStrings = [{\n                s: 'Windows 10',\n                r: /(Windows 10.0|Windows NT 10.0)/\n            }, {\n                s: 'Windows 8.1',\n                r: /(Windows 8.1|Windows NT 6.3)/\n            }, {\n                s: 'Windows 8',\n                r: /(Windows 8|Windows NT 6.2)/\n            }, {\n                s: 'Windows 7',\n                r: /(Windows 7|Windows NT 6.1)/\n            }, {\n                s: 'Windows Vista',\n                r: /Windows NT 6.0/\n            }, {\n                s: 'Windows Server 2003',\n                r: /Windows NT 5.2/\n            }, {\n                s: 'Windows XP',\n                r: /(Windows NT 5.1|Windows XP)/\n            }, {\n                s: 'Windows 2000',\n                r: /(Windows NT 5.0|Windows 2000)/\n            }, {\n                s: 'Windows ME',\n                r: /(Win 9x 4.90|Windows ME)/\n            }, {\n                s: 'Windows 98',\n                r: /(Windows 98|Win98)/\n            }, {\n                s: 'Windows 95',\n                r: /(Windows 95|Win95|Windows_95)/\n            }, {\n                s: 'Windows NT 4.0',\n                r: /(Windows NT 4.0|WinNT4.0|WinNT|Windows NT)/\n            }, {\n                s: 'Windows CE',\n                r: /Windows CE/\n            }, {\n                s: 'Windows 3.11',\n                r: /Win16/\n            }, {\n                s: 'Android',\n                r: /Android/\n            }, {\n                s: 'Open BSD',\n                r: /OpenBSD/\n            }, {\n                s: 'Sun OS',\n                r: /SunOS/\n            }, {\n                s: 'Linux',\n                r: /(Linux|X11)/\n            }, {\n                s: 'iOS',\n                r: /(iPhone|iPad|iPod)/\n            }, {\n                s: 'Mac OS X',\n                r: /Mac OS X/\n            }, {\n                s: 'Mac OS',\n                r: /(MacPPC|MacIntel|Mac_PowerPC|Macintosh)/\n            }, {\n                s: 'QNX',\n                r: /QNX/\n            }, {\n                s: 'UNIX',\n                r: /UNIX/\n            }, {\n                s: 'BeOS',\n                r: /BeOS/\n            }, {\n                s: 'OS/2',\n                r: /OS\\/2/\n            }, {\n                s: 'Search Bot',\n                r: /(nuhk|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask Jeeves\\/Teoma|ia_archiver)/\n            }];\n            for (var i = 0, cs; cs = clientStrings[i]; i++) {\n                if (cs.r.test(nAgt)) {\n                    os = cs.s;\n                    break;\n                }\n            }\n\n            var osVersion = unknown;\n\n            if (/Windows/.test(os)) {\n                if (/Windows (.*)/.test(os)) {\n                    osVersion = /Windows (.*)/.exec(os)[1];\n                }\n                os = 'Windows';\n            }\n\n            switch (os) {\n                case 'Mac OS X':\n                    if (/Mac OS X (10[\\.\\_\\d]+)/.test(nAgt)) {\n                        osVersion = /Mac OS X (10[\\.\\_\\d]+)/.exec(nAgt)[1];\n                    }\n                    break;\n                case 'Android':\n                    if (/Android ([\\.\\_\\d]+)/.test(nAgt)) {\n                        osVersion = /Android ([\\.\\_\\d]+)/.exec(nAgt)[1];\n                    }\n                    break;\n                case 'iOS':\n                    if (/OS (\\d+)_(\\d+)_?(\\d+)?/.test(nAgt)) {\n                        osVersion = /OS (\\d+)_(\\d+)_?(\\d+)?/.exec(nVer);\n                        osVersion = osVersion[1] + '.' + osVersion[2] + '.' + (osVersion[3] | 0);\n                    }\n                    break;\n            }\n\n            return {\n                osName: os,\n                osVersion: osVersion\n            };\n        }\n\n        var osName = 'Unknown OS';\n        var osVersion = 'Unknown OS Version';\n\n        function getAndroidVersion(ua) {\n            ua = (ua || navigator.userAgent).toLowerCase();\n            var match = ua.match(/android\\s([0-9\\.]*)/);\n            return match ? match[1] : false;\n        }\n\n        var osInfo = detectDesktopOS();\n\n        if (osInfo && osInfo.osName && osInfo.osName != '-') {\n            osName = osInfo.osName;\n            osVersion = osInfo.osVersion;\n        } else if (isMobile.any()) {\n            osName = isMobile.getOsName();\n\n            if (osName == 'Android') {\n                osVersion = getAndroidVersion();\n            }\n        }\n\n        var isNodejs = typeof process === 'object' && typeof process.versions === 'object' && process.versions.node;\n\n        if (osName === 'Unknown OS' && isNodejs) {\n            osName = 'Nodejs';\n            osVersion = process.versions.node.toString().replace('v', '');\n        }\n\n        var isCanvasSupportsStreamCapturing = false;\n        var isVideoSupportsStreamCapturing = false;\n        ['captureStream', 'mozCaptureStream', 'webkitCaptureStream'].forEach(function(item) {\n            if (typeof document === 'undefined' || typeof document.createElement !== 'function') {\n                return;\n            }\n\n            if (!isCanvasSupportsStreamCapturing && item in document.createElement('canvas')) {\n                isCanvasSupportsStreamCapturing = true;\n            }\n\n            if (!isVideoSupportsStreamCapturing && item in document.createElement('video')) {\n                isVideoSupportsStreamCapturing = true;\n            }\n        });\n\n        var regexIpv4Local = /^(192\\.168\\.|169\\.254\\.|10\\.|172\\.(1[6-9]|2\\d|3[01]))/,\n            regexIpv4 = /([0-9]{1,3}(\\.[0-9]{1,3}){3})/,\n            regexIpv6 = /[a-f0-9]{1,4}(:[a-f0-9]{1,4}){7}/;\n\n        // via: https://github.com/diafygi/webrtc-ips\n        function DetectLocalIPAddress(callback, stream) {\n            if (!DetectRTC.isWebRTCSupported) {\n                return;\n            }\n\n            var isPublic = true,\n                isIpv4 = true;\n            getIPs(function(ip) {\n                if (!ip) {\n                    callback(); // Pass nothing to tell that ICE-gathering-ended\n                } else if (ip.match(regexIpv4Local)) {\n                    isPublic = false;\n                    callback('Local: ' + ip, isPublic, isIpv4);\n                } else if (ip.match(regexIpv6)) { //via https://ourcodeworld.com/articles/read/257/how-to-get-the-client-ip-address-with-javascript-only\n                    isIpv4 = false;\n                    callback('Public: ' + ip, isPublic, isIpv4);\n                } else {\n                    callback('Public: ' + ip, isPublic, isIpv4);\n                }\n            }, stream);\n        }\n\n        function getIPs(callback, stream) {\n            if (typeof document === 'undefined' || typeof document.getElementById !== 'function') {\n                return;\n            }\n\n            var ipDuplicates = {};\n\n            var RTCPeerConnection = window.RTCPeerConnection || window.mozRTCPeerConnection || window.webkitRTCPeerConnection;\n\n            if (!RTCPeerConnection) {\n                var iframe = document.getElementById('iframe');\n                if (!iframe) {\n                    return;\n                }\n                var win = iframe.contentWindow;\n                RTCPeerConnection = win.RTCPeerConnection || win.mozRTCPeerConnection || win.webkitRTCPeerConnection;\n            }\n\n            if (!RTCPeerConnection) {\n                return;\n            }\n\n            var peerConfig = null;\n\n            if (DetectRTC.browser === 'Chrome' && DetectRTC.browser.version < 58) {\n                // todo: add support for older Opera\n                peerConfig = {\n                    optional: [{\n                        RtpDataChannels: true\n                    }]\n                };\n            }\n\n            var servers = {\n                iceServers: [{\n                    urls: 'stun:stun.l.google.com:19302'\n                }]\n            };\n\n            var pc = new RTCPeerConnection(servers, peerConfig);\n\n            if (stream) {\n                if (pc.addStream) {\n                    pc.addStream(stream);\n                } else if (pc.addTrack && stream.getTracks()[0]) {\n                    pc.addTrack(stream.getTracks()[0], stream);\n                }\n            }\n\n            function handleCandidate(candidate) {\n                if (!candidate) {\n                    callback(); // Pass nothing to tell that ICE-gathering-ended\n                    return;\n                }\n\n                var match = regexIpv4.exec(candidate);\n                if (!match) {\n                    return;\n                }\n                var ipAddress = match[1];\n                var isPublic = (candidate.match(regexIpv4Local)),\n                    isIpv4 = true;\n\n                if (ipDuplicates[ipAddress] === undefined) {\n                    callback(ipAddress, isPublic, isIpv4);\n                }\n\n                ipDuplicates[ipAddress] = true;\n            }\n\n            // listen for candidate events\n            pc.onicecandidate = function(event) {\n                if (event.candidate && event.candidate.candidate) {\n                    handleCandidate(event.candidate.candidate);\n                } else {\n                    handleCandidate(); // Pass nothing to tell that ICE-gathering-ended\n                }\n            };\n\n            // create data channel\n            if (!stream) {\n                try {\n                    pc.createDataChannel('sctp', {});\n                } catch (e) {}\n            }\n\n            // create an offer sdp\n            if (DetectRTC.isPromisesSupported) {\n                pc.createOffer().then(function(result) {\n                    pc.setLocalDescription(result).then(afterCreateOffer);\n                });\n            } else {\n                pc.createOffer(function(result) {\n                    pc.setLocalDescription(result, afterCreateOffer, function() {});\n                }, function() {});\n            }\n\n            function afterCreateOffer() {\n                var lines = pc.localDescription.sdp.split('\\n');\n\n                lines.forEach(function(line) {\n                    if (line && line.indexOf('a=candidate:') === 0) {\n                        handleCandidate(line);\n                    }\n                });\n            }\n        }\n\n        var MediaDevices = [];\n\n        var audioInputDevices = [];\n        var audioOutputDevices = [];\n        var videoInputDevices = [];\n\n        if (navigator.mediaDevices && navigator.mediaDevices.enumerateDevices) {\n            // Firefox 38+ seems having support of enumerateDevices\n            // Thanks @xdumaine/enumerateDevices\n            navigator.enumerateDevices = function(callback) {\n                var enumerateDevices = navigator.mediaDevices.enumerateDevices();\n                if (enumerateDevices && enumerateDevices.then) {\n                    navigator.mediaDevices.enumerateDevices().then(callback).catch(function() {\n                        callback([]);\n                    });\n                } else {\n                    callback([]);\n                }\n            };\n        }\n\n        // Media Devices detection\n        var canEnumerate = false;\n\n        /*global MediaStreamTrack:true */\n        if (typeof MediaStreamTrack !== 'undefined' && 'getSources' in MediaStreamTrack) {\n            canEnumerate = true;\n        } else if (navigator.mediaDevices && !!navigator.mediaDevices.enumerateDevices) {\n            canEnumerate = true;\n        }\n\n        var hasMicrophone = false;\n        var hasSpeakers = false;\n        var hasWebcam = false;\n\n        var isWebsiteHasMicrophonePermissions = false;\n        var isWebsiteHasWebcamPermissions = false;\n\n        // http://dev.w3.org/2011/webrtc/editor/getusermedia.html#mediadevices\n        function checkDeviceSupport(callback) {\n            if (!canEnumerate) {\n                if (callback) {\n                    callback();\n                }\n                return;\n            }\n\n            if (!navigator.enumerateDevices && window.MediaStreamTrack && window.MediaStreamTrack.getSources) {\n                navigator.enumerateDevices = window.MediaStreamTrack.getSources.bind(window.MediaStreamTrack);\n            }\n\n            if (!navigator.enumerateDevices && navigator.enumerateDevices) {\n                navigator.enumerateDevices = navigator.enumerateDevices.bind(navigator);\n            }\n\n            if (!navigator.enumerateDevices) {\n                if (callback) {\n                    callback();\n                }\n                return;\n            }\n\n            MediaDevices = [];\n\n            audioInputDevices = [];\n            audioOutputDevices = [];\n            videoInputDevices = [];\n\n            hasMicrophone = false;\n            hasSpeakers = false;\n            hasWebcam = false;\n\n            isWebsiteHasMicrophonePermissions = false;\n            isWebsiteHasWebcamPermissions = false;\n\n            // to prevent duplication\n            var alreadyUsedDevices = {};\n\n            navigator.enumerateDevices(function(devices) {\n                devices.forEach(function(_device) {\n                    var device = {};\n                    for (var d in _device) {\n                        try {\n                            if (typeof _device[d] !== 'function') {\n                                device[d] = _device[d];\n                            }\n                        } catch (e) {}\n                    }\n\n                    if (alreadyUsedDevices[device.deviceId + device.label + device.kind]) {\n                        return;\n                    }\n\n                    // if it is MediaStreamTrack.getSources\n                    if (device.kind === 'audio') {\n                        device.kind = 'audioinput';\n                    }\n\n                    if (device.kind === 'video') {\n                        device.kind = 'videoinput';\n                    }\n\n                    if (!device.deviceId) {\n                        device.deviceId = device.id;\n                    }\n\n                    if (!device.id) {\n                        device.id = device.deviceId;\n                    }\n\n                    if (!device.label) {\n                        device.isCustomLabel = true;\n\n                        if (device.kind === 'videoinput') {\n                            device.label = 'Camera ' + (videoInputDevices.length + 1);\n                        } else if (device.kind === 'audioinput') {\n                            device.label = 'Microphone ' + (audioInputDevices.length + 1);\n                        } else if (device.kind === 'audiooutput') {\n                            device.label = 'Speaker ' + (audioOutputDevices.length + 1);\n                        } else {\n                            device.label = 'Please invoke getUserMedia once.';\n                        }\n\n                        if (typeof DetectRTC !== 'undefined' && DetectRTC.browser.isChrome && DetectRTC.browser.version >= 46 && !/^(https:|chrome-extension:)$/g.test(location.protocol || '')) {\n                            if (typeof document !== 'undefined' && typeof document.domain === 'string' && document.domain.search && document.domain.search(/localhost|127.0./g) === -1) {\n                                device.label = 'HTTPs is required to get label of this ' + device.kind + ' device.';\n                            }\n                        }\n                    } else {\n                        // Firefox on Android still returns empty label\n                        if (device.kind === 'videoinput' && !isWebsiteHasWebcamPermissions) {\n                            isWebsiteHasWebcamPermissions = true;\n                        }\n\n                        if (device.kind === 'audioinput' && !isWebsiteHasMicrophonePermissions) {\n                            isWebsiteHasMicrophonePermissions = true;\n                        }\n                    }\n\n                    if (device.kind === 'audioinput') {\n                        hasMicrophone = true;\n\n                        if (audioInputDevices.indexOf(device) === -1) {\n                            audioInputDevices.push(device);\n                        }\n                    }\n\n                    if (device.kind === 'audiooutput') {\n                        hasSpeakers = true;\n\n                        if (audioOutputDevices.indexOf(device) === -1) {\n                            audioOutputDevices.push(device);\n                        }\n                    }\n\n                    if (device.kind === 'videoinput') {\n                        hasWebcam = true;\n\n                        if (videoInputDevices.indexOf(device) === -1) {\n                            videoInputDevices.push(device);\n                        }\n                    }\n\n                    // there is no 'videoouput' in the spec.\n                    MediaDevices.push(device);\n\n                    alreadyUsedDevices[device.deviceId + device.label + device.kind] = device;\n                });\n\n                if (typeof DetectRTC !== 'undefined') {\n                    // to sync latest outputs\n                    DetectRTC.MediaDevices = MediaDevices;\n                    DetectRTC.hasMicrophone = hasMicrophone;\n                    DetectRTC.hasSpeakers = hasSpeakers;\n                    DetectRTC.hasWebcam = hasWebcam;\n\n                    DetectRTC.isWebsiteHasWebcamPermissions = isWebsiteHasWebcamPermissions;\n                    DetectRTC.isWebsiteHasMicrophonePermissions = isWebsiteHasMicrophonePermissions;\n\n                    DetectRTC.audioInputDevices = audioInputDevices;\n                    DetectRTC.audioOutputDevices = audioOutputDevices;\n                    DetectRTC.videoInputDevices = videoInputDevices;\n                }\n\n                if (callback) {\n                    callback();\n                }\n            });\n        }\n\n        var DetectRTC = window.DetectRTC || {};\n\n        // ----------\n        // DetectRTC.browser.name || DetectRTC.browser.version || DetectRTC.browser.fullVersion\n        DetectRTC.browser = getBrowserInfo();\n\n        detectPrivateMode(function(isPrivateBrowsing) {\n            DetectRTC.browser.isPrivateBrowsing = !!isPrivateBrowsing;\n        });\n\n        // DetectRTC.isChrome || DetectRTC.isFirefox || DetectRTC.isEdge\n        DetectRTC.browser['is' + DetectRTC.browser.name] = true;\n\n        // -----------\n        DetectRTC.osName = osName;\n        DetectRTC.osVersion = osVersion;\n\n        var isNodeWebkit = typeof process === 'object' && typeof process.versions === 'object' && process.versions['node-webkit'];\n\n        // --------- Detect if system supports WebRTC 1.0 or WebRTC 1.1.\n        var isWebRTCSupported = false;\n        ['RTCPeerConnection', 'webkitRTCPeerConnection', 'mozRTCPeerConnection', 'RTCIceGatherer'].forEach(function(item) {\n            if (isWebRTCSupported) {\n                return;\n            }\n\n            if (item in window) {\n                isWebRTCSupported = true;\n            }\n        });\n        DetectRTC.isWebRTCSupported = isWebRTCSupported;\n\n        //-------\n        DetectRTC.isORTCSupported = typeof RTCIceGatherer !== 'undefined';\n\n        // --------- Detect if system supports screen capturing API\n        var isScreenCapturingSupported = false;\n        if (DetectRTC.browser.isChrome && DetectRTC.browser.version >= 35) {\n            isScreenCapturingSupported = true;\n        } else if (DetectRTC.browser.isFirefox && DetectRTC.browser.version >= 34) {\n            isScreenCapturingSupported = true;\n        } else if (DetectRTC.browser.isEdge && DetectRTC.browser.version >= 17) {\n            isScreenCapturingSupported = true; // navigator.getDisplayMedia\n        } else if (DetectRTC.osName === 'Android' && DetectRTC.browser.isChrome) {\n            isScreenCapturingSupported = true;\n        }\n\n        if (!/^(https:|chrome-extension:)$/g.test(location.protocol || '')) {\n            var isNonLocalHost = typeof document !== 'undefined' && typeof document.domain === 'string' && document.domain.search && document.domain.search(/localhost|127.0./g) === -1;\n            if (isNonLocalHost && (DetectRTC.browser.isChrome || DetectRTC.browser.isEdge || DetectRTC.browser.isOpera)) {\n                isScreenCapturingSupported = false;\n            } else if (DetectRTC.browser.isFirefox) {\n                isScreenCapturingSupported = false;\n            }\n        }\n        DetectRTC.isScreenCapturingSupported = isScreenCapturingSupported;\n\n        // --------- Detect if WebAudio API are supported\n        var webAudio = {\n            isSupported: false,\n            isCreateMediaStreamSourceSupported: false\n        };\n\n        ['AudioContext', 'webkitAudioContext', 'mozAudioContext', 'msAudioContext'].forEach(function(item) {\n            if (webAudio.isSupported) {\n                return;\n            }\n\n            if (item in window) {\n                webAudio.isSupported = true;\n\n                if (window[item] && 'createMediaStreamSource' in window[item].prototype) {\n                    webAudio.isCreateMediaStreamSourceSupported = true;\n                }\n            }\n        });\n        DetectRTC.isAudioContextSupported = webAudio.isSupported;\n        DetectRTC.isCreateMediaStreamSourceSupported = webAudio.isCreateMediaStreamSourceSupported;\n\n        // ---------- Detect if SCTP/RTP channels are supported.\n\n        var isRtpDataChannelsSupported = false;\n        if (DetectRTC.browser.isChrome && DetectRTC.browser.version > 31) {\n            isRtpDataChannelsSupported = true;\n        }\n        DetectRTC.isRtpDataChannelsSupported = isRtpDataChannelsSupported;\n\n        var isSCTPSupportd = false;\n        if (DetectRTC.browser.isFirefox && DetectRTC.browser.version > 28) {\n            isSCTPSupportd = true;\n        } else if (DetectRTC.browser.isChrome && DetectRTC.browser.version > 25) {\n            isSCTPSupportd = true;\n        } else if (DetectRTC.browser.isOpera && DetectRTC.browser.version >= 11) {\n            isSCTPSupportd = true;\n        }\n        DetectRTC.isSctpDataChannelsSupported = isSCTPSupportd;\n\n        // ---------\n\n        DetectRTC.isMobileDevice = isMobileDevice; // \"isMobileDevice\" boolean is defined in \"getBrowserInfo.js\"\n\n        // ------\n        var isGetUserMediaSupported = false;\n        if (navigator.getUserMedia) {\n            isGetUserMediaSupported = true;\n        } else if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {\n            isGetUserMediaSupported = true;\n        }\n\n        if (DetectRTC.browser.isChrome && DetectRTC.browser.version >= 46 && !/^(https:|chrome-extension:)$/g.test(location.protocol || '')) {\n            if (typeof document !== 'undefined' && typeof document.domain === 'string' && document.domain.search && document.domain.search(/localhost|127.0./g) === -1) {\n                isGetUserMediaSupported = 'Requires HTTPs';\n            }\n        }\n\n        if (DetectRTC.osName === 'Nodejs') {\n            isGetUserMediaSupported = false;\n        }\n        DetectRTC.isGetUserMediaSupported = isGetUserMediaSupported;\n\n        var displayResolution = '';\n        if (screen.width) {\n            var width = (screen.width) ? screen.width : '';\n            var height = (screen.height) ? screen.height : '';\n            displayResolution += '' + width + ' x ' + height;\n        }\n        DetectRTC.displayResolution = displayResolution;\n\n        function getAspectRatio(w, h) {\n            function gcd(a, b) {\n                return (b == 0) ? a : gcd(b, a % b);\n            }\n            var r = gcd(w, h);\n            return (w / r) / (h / r);\n        }\n\n        DetectRTC.displayAspectRatio = getAspectRatio(screen.width, screen.height).toFixed(2);\n\n        // ----------\n        DetectRTC.isCanvasSupportsStreamCapturing = isCanvasSupportsStreamCapturing;\n        DetectRTC.isVideoSupportsStreamCapturing = isVideoSupportsStreamCapturing;\n\n        if (DetectRTC.browser.name == 'Chrome' && DetectRTC.browser.version >= 53) {\n            if (!DetectRTC.isCanvasSupportsStreamCapturing) {\n                DetectRTC.isCanvasSupportsStreamCapturing = 'Requires chrome flag: enable-experimental-web-platform-features';\n            }\n\n            if (!DetectRTC.isVideoSupportsStreamCapturing) {\n                DetectRTC.isVideoSupportsStreamCapturing = 'Requires chrome flag: enable-experimental-web-platform-features';\n            }\n        }\n\n        // ------\n        DetectRTC.DetectLocalIPAddress = DetectLocalIPAddress;\n\n        DetectRTC.isWebSocketsSupported = 'WebSocket' in window && 2 === window.WebSocket.CLOSING;\n        DetectRTC.isWebSocketsBlocked = !DetectRTC.isWebSocketsSupported;\n\n        if (DetectRTC.osName === 'Nodejs') {\n            DetectRTC.isWebSocketsSupported = true;\n            DetectRTC.isWebSocketsBlocked = false;\n        }\n\n        DetectRTC.checkWebSocketsSupport = function(callback) {\n            callback = callback || function() {};\n            try {\n                var starttime;\n                var websocket = new WebSocket('wss://echo.websocket.org:443/');\n                websocket.onopen = function() {\n                    DetectRTC.isWebSocketsBlocked = false;\n                    starttime = (new Date).getTime();\n                    websocket.send('ping');\n                };\n                websocket.onmessage = function() {\n                    DetectRTC.WebsocketLatency = (new Date).getTime() - starttime + 'ms';\n                    callback();\n                    websocket.close();\n                    websocket = null;\n                };\n                websocket.onerror = function() {\n                    DetectRTC.isWebSocketsBlocked = true;\n                    callback();\n                };\n            } catch (e) {\n                DetectRTC.isWebSocketsBlocked = true;\n                callback();\n            }\n        };\n\n        // -------\n        DetectRTC.load = function(callback) {\n            callback = callback || function() {};\n            checkDeviceSupport(callback);\n        };\n\n        // check for microphone/camera support!\n        if (typeof checkDeviceSupport === 'function') {\n            // checkDeviceSupport();\n        }\n\n        if (typeof MediaDevices !== 'undefined') {\n            DetectRTC.MediaDevices = MediaDevices;\n        } else {\n            DetectRTC.MediaDevices = [];\n        }\n\n        DetectRTC.hasMicrophone = hasMicrophone;\n        DetectRTC.hasSpeakers = hasSpeakers;\n        DetectRTC.hasWebcam = hasWebcam;\n\n        DetectRTC.isWebsiteHasWebcamPermissions = isWebsiteHasWebcamPermissions;\n        DetectRTC.isWebsiteHasMicrophonePermissions = isWebsiteHasMicrophonePermissions;\n\n        DetectRTC.audioInputDevices = audioInputDevices;\n        DetectRTC.audioOutputDevices = audioOutputDevices;\n        DetectRTC.videoInputDevices = videoInputDevices;\n\n        // ------\n        var isSetSinkIdSupported = false;\n        if (typeof document !== 'undefined' && typeof document.createElement === 'function' && 'setSinkId' in document.createElement('video')) {\n            isSetSinkIdSupported = true;\n        }\n        DetectRTC.isSetSinkIdSupported = isSetSinkIdSupported;\n\n        // -----\n        var isRTPSenderReplaceTracksSupported = false;\n        if (DetectRTC.browser.isFirefox && typeof mozRTCPeerConnection !== 'undefined' /*&& DetectRTC.browser.version > 39*/ ) {\n            /*global mozRTCPeerConnection:true */\n            if ('getSenders' in mozRTCPeerConnection.prototype) {\n                isRTPSenderReplaceTracksSupported = true;\n            }\n        } else if (DetectRTC.browser.isChrome && typeof webkitRTCPeerConnection !== 'undefined') {\n            /*global webkitRTCPeerConnection:true */\n            if ('getSenders' in webkitRTCPeerConnection.prototype) {\n                isRTPSenderReplaceTracksSupported = true;\n            }\n        }\n        DetectRTC.isRTPSenderReplaceTracksSupported = isRTPSenderReplaceTracksSupported;\n\n        //------\n        var isRemoteStreamProcessingSupported = false;\n        if (DetectRTC.browser.isFirefox && DetectRTC.browser.version > 38) {\n            isRemoteStreamProcessingSupported = true;\n        }\n        DetectRTC.isRemoteStreamProcessingSupported = isRemoteStreamProcessingSupported;\n\n        //-------\n        var isApplyConstraintsSupported = false;\n\n        /*global MediaStreamTrack:true */\n        if (typeof MediaStreamTrack !== 'undefined' && 'applyConstraints' in MediaStreamTrack.prototype) {\n            isApplyConstraintsSupported = true;\n        }\n        DetectRTC.isApplyConstraintsSupported = isApplyConstraintsSupported;\n\n        //-------\n        var isMultiMonitorScreenCapturingSupported = false;\n        if (DetectRTC.browser.isFirefox && DetectRTC.browser.version >= 43) {\n            // version 43 merely supports platforms for multi-monitors\n            // version 44 will support exact multi-monitor selection i.e. you can select any monitor for screen capturing.\n            isMultiMonitorScreenCapturingSupported = true;\n        }\n        DetectRTC.isMultiMonitorScreenCapturingSupported = isMultiMonitorScreenCapturingSupported;\n\n        DetectRTC.isPromisesSupported = !!('Promise' in window);\n\n        // version is generated by \"grunt\"\n        DetectRTC.version = '1.3.9';\n\n        if (typeof DetectRTC === 'undefined') {\n            window.DetectRTC = {};\n        }\n\n        var MediaStream = window.MediaStream;\n\n        if (typeof MediaStream === 'undefined' && typeof webkitMediaStream !== 'undefined') {\n            MediaStream = webkitMediaStream;\n        }\n\n        if (typeof MediaStream !== 'undefined' && typeof MediaStream === 'function') {\n            DetectRTC.MediaStream = Object.keys(MediaStream.prototype);\n        } else DetectRTC.MediaStream = false;\n\n        if (typeof MediaStreamTrack !== 'undefined') {\n            DetectRTC.MediaStreamTrack = Object.keys(MediaStreamTrack.prototype);\n        } else DetectRTC.MediaStreamTrack = false;\n\n        var RTCPeerConnection = window.RTCPeerConnection || window.mozRTCPeerConnection || window.webkitRTCPeerConnection;\n\n        if (typeof RTCPeerConnection !== 'undefined') {\n            DetectRTC.RTCPeerConnection = Object.keys(RTCPeerConnection.prototype);\n        } else DetectRTC.RTCPeerConnection = false;\n\n        window.DetectRTC = DetectRTC;\n\n        if (true /* && !!module.exports*/ ) {\n            module.exports = DetectRTC;\n        }\n\n        if (true) {\n            !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {\n                return DetectRTC;\n            }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n        }\n    })();\n\n    // globals.js\n\n    if (typeof cordova !== 'undefined') {\n        DetectRTC.isMobileDevice = true;\n        DetectRTC.browser.name = 'Chrome';\n    }\n\n    if (navigator && navigator.userAgent && navigator.userAgent.indexOf('Crosswalk') !== -1) {\n        DetectRTC.isMobileDevice = true;\n        DetectRTC.browser.name = 'Chrome';\n    }\n\n    function fireEvent(obj, eventName, args) {\n        if (typeof CustomEvent === 'undefined') {\n            return;\n        }\n\n        var eventDetail = {\n            arguments: args,\n            __exposedProps__: args\n        };\n\n        var event = new CustomEvent(eventName, eventDetail);\n        obj.dispatchEvent(event);\n    }\n\n    function setHarkEvents(connection, streamEvent) {\n        if (!streamEvent.stream || !getTracks(streamEvent.stream, 'audio').length) return;\n\n        if (!connection || !streamEvent) {\n            throw 'Both arguments are required.';\n        }\n\n        if (!connection.onspeaking || !connection.onsilence) {\n            return;\n        }\n\n        if (typeof hark === 'undefined') {\n            throw 'hark.js not found.';\n        }\n\n        hark(streamEvent.stream, {\n            onspeaking: function() {\n                connection.onspeaking(streamEvent);\n            },\n            onsilence: function() {\n                connection.onsilence(streamEvent);\n            },\n            onvolumechange: function(volume, threshold) {\n                if (!connection.onvolumechange) {\n                    return;\n                }\n                connection.onvolumechange(merge({\n                    volume: volume,\n                    threshold: threshold\n                }, streamEvent));\n            }\n        });\n    }\n\n    function setMuteHandlers(connection, streamEvent) {\n        if (!streamEvent.stream || !streamEvent.stream || !streamEvent.stream.addEventListener) return;\n\n        streamEvent.stream.addEventListener('mute', function(event) {\n            event = connection.streamEvents[streamEvent.streamid];\n\n            event.session = {\n                audio: event.muteType === 'audio',\n                video: event.muteType === 'video'\n            };\n\n            connection.onmute(event);\n        }, false);\n\n        streamEvent.stream.addEventListener('unmute', function(event) {\n            event = connection.streamEvents[streamEvent.streamid];\n\n            event.session = {\n                audio: event.unmuteType === 'audio',\n                video: event.unmuteType === 'video'\n            };\n\n            connection.onunmute(event);\n        }, false);\n    }\n\n    function getRandomString() {\n        if (window.crypto && window.crypto.getRandomValues && navigator.userAgent.indexOf('Safari') === -1) {\n            var a = window.crypto.getRandomValues(new Uint32Array(3)),\n                token = '';\n            for (var i = 0, l = a.length; i < l; i++) {\n                token += a[i].toString(36);\n            }\n            return token;\n        } else {\n            return (Math.random() * new Date().getTime()).toString(36).replace(/\\./g, '');\n        }\n    }\n\n    // Get HTMLAudioElement/HTMLVideoElement accordingly\n    // todo: add API documentation for connection.autoCreateMediaElement\n\n    function getRMCMediaElement(stream, callback, connection) {\n        if (!connection.autoCreateMediaElement) {\n            callback({});\n            return;\n        }\n\n        var isAudioOnly = false;\n        if (!getTracks(stream, 'video').length && !stream.isVideo && !stream.isScreen) {\n            isAudioOnly = true;\n        }\n\n        if (DetectRTC.browser.name === 'Firefox') {\n            if (connection.session.video || connection.session.screen) {\n                isAudioOnly = false;\n            }\n        }\n\n        var mediaElement = document.createElement(isAudioOnly ? 'audio' : 'video');\n\n        mediaElement.srcObject = stream;\n\n        mediaElement.setAttribute('autoplay', true);\n        mediaElement.setAttribute('playsinline', true);\n        mediaElement.setAttribute('controls', true);\n        mediaElement.setAttribute('muted', false);\n        mediaElement.setAttribute('volume', 1);\n\n        // http://goo.gl/WZ5nFl\n        // Firefox don't yet support onended for any stream (remote/local)\n        if (DetectRTC.browser.name === 'Firefox') {\n            var streamEndedEvent = 'ended';\n\n            if ('oninactive' in mediaElement) {\n                streamEndedEvent = 'inactive';\n            }\n\n            mediaElement.addEventListener(streamEndedEvent, function() {\n                // fireEvent(stream, streamEndedEvent, stream);\n                currentUserMediaRequest.remove(stream.idInstance);\n\n                if (stream.type === 'local') {\n                    streamEndedEvent = 'ended';\n\n                    if ('oninactive' in stream) {\n                        streamEndedEvent = 'inactive';\n                    }\n\n                    StreamsHandler.onSyncNeeded(stream.streamid, streamEndedEvent);\n\n                    connection.attachStreams.forEach(function(aStream, idx) {\n                        if (stream.streamid === aStream.streamid) {\n                            delete connection.attachStreams[idx];\n                        }\n                    });\n\n                    var newStreamsArray = [];\n                    connection.attachStreams.forEach(function(aStream) {\n                        if (aStream) {\n                            newStreamsArray.push(aStream);\n                        }\n                    });\n                    connection.attachStreams = newStreamsArray;\n\n                    var streamEvent = connection.streamEvents[stream.streamid];\n\n                    if (streamEvent) {\n                        connection.onstreamended(streamEvent);\n                        return;\n                    }\n                    if (this.parentNode) {\n                        this.parentNode.removeChild(this);\n                    }\n                }\n            }, false);\n        }\n\n        var played = mediaElement.play();\n        if (typeof played !== 'undefined') {\n            var cbFired = false;\n            setTimeout(function() {\n                if (!cbFired) {\n                    cbFired = true;\n                    callback(mediaElement);\n                }\n            }, 1000);\n            played.then(function() {\n                if (cbFired) return;\n                cbFired = true;\n                callback(mediaElement);\n            }).catch(function(error) {\n                if (cbFired) return;\n                cbFired = true;\n                callback(mediaElement);\n            });\n        } else {\n            callback(mediaElement);\n        }\n    }\n\n    // if IE\n    if (!window.addEventListener) {\n        window.addEventListener = function(el, eventName, eventHandler) {\n            if (!el.attachEvent) {\n                return;\n            }\n            el.attachEvent('on' + eventName, eventHandler);\n        };\n    }\n\n    function listenEventHandler(eventName, eventHandler) {\n        window.removeEventListener(eventName, eventHandler);\n        window.addEventListener(eventName, eventHandler, false);\n    }\n\n    window.attachEventListener = function(video, type, listener, useCapture) {\n        video.addEventListener(type, listener, useCapture);\n    };\n\n    function removeNullEntries(array) {\n        var newArray = [];\n        array.forEach(function(item) {\n            if (item) {\n                newArray.push(item);\n            }\n        });\n        return newArray;\n    }\n\n\n    function isData(session) {\n        return !session.audio && !session.video && !session.screen && session.data;\n    }\n\n    function isNull(obj) {\n        return typeof obj === 'undefined';\n    }\n\n    function isString(obj) {\n        return typeof obj === 'string';\n    }\n\n    var MediaStream = window.MediaStream;\n\n    if (typeof MediaStream === 'undefined' && typeof webkitMediaStream !== 'undefined') {\n        MediaStream = webkitMediaStream;\n    }\n\n    /*global MediaStream:true */\n    if (typeof MediaStream !== 'undefined') {\n        if (!('stop' in MediaStream.prototype)) {\n            MediaStream.prototype.stop = function() {\n                this.getTracks().forEach(function(track) {\n                    track.stop();\n                });\n            };\n        }\n    }\n\n    function isAudioPlusTab(connection, audioPlusTab) {\n        if (connection.session.audio && connection.session.audio === 'two-way') {\n            return false;\n        }\n\n        if (DetectRTC.browser.name === 'Firefox' && audioPlusTab !== false) {\n            return true;\n        }\n\n        if (DetectRTC.browser.name !== 'Chrome' || DetectRTC.browser.version < 50) return false;\n\n        if (typeof audioPlusTab === true) {\n            return true;\n        }\n\n        if (typeof audioPlusTab === 'undefined' && connection.session.audio && connection.session.screen && !connection.session.video) {\n            audioPlusTab = true;\n            return true;\n        }\n\n        return false;\n    }\n\n    function getAudioScreenConstraints(screen_constraints) {\n        if (DetectRTC.browser.name === 'Firefox') {\n            return true;\n        }\n\n        if (DetectRTC.browser.name !== 'Chrome') return false;\n\n        return {\n            mandatory: {\n                chromeMediaSource: screen_constraints.mandatory.chromeMediaSource,\n                chromeMediaSourceId: screen_constraints.mandatory.chromeMediaSourceId\n            }\n        };\n    }\n\n    window.iOSDefaultAudioOutputDevice = window.iOSDefaultAudioOutputDevice || 'speaker'; // earpiece or speaker\n\n    function getTracks(stream, kind) {\n        if (!stream || !stream.getTracks) {\n            return [];\n        }\n\n        return stream.getTracks().filter(function(t) {\n            return t.kind === (kind || 'audio');\n        });\n    }\n\n    function isUnifiedPlanSupportedDefault() {\n        var canAddTransceiver = false;\n\n        try {\n            if (typeof RTCRtpTransceiver === 'undefined') return false;\n            if (!('currentDirection' in RTCRtpTransceiver.prototype)) return false;\n\n            var tempPc = new RTCPeerConnection();\n\n            try {\n                tempPc.addTransceiver('audio');\n                canAddTransceiver = true;\n            } catch (e) {}\n\n            tempPc.close();\n        } catch (e) {\n            canAddTransceiver = false;\n        }\n\n        return canAddTransceiver && isUnifiedPlanSuppored();\n    }\n\n    function isUnifiedPlanSuppored() {\n        var isUnifiedPlanSupported = false;\n\n        try {\n            var pc = new RTCPeerConnection({\n                sdpSemantics: 'unified-plan'\n            });\n\n            try {\n                var config = pc.getConfiguration();\n                if (config.sdpSemantics == 'unified-plan')\n                    isUnifiedPlanSupported = true;\n                else if (config.sdpSemantics == 'plan-b')\n                    isUnifiedPlanSupported = false;\n                else\n                    isUnifiedPlanSupported = false;\n            } catch (e) {\n                isUnifiedPlanSupported = false;\n            }\n        } catch (e) {\n            isUnifiedPlanSupported = false;\n        }\n\n        return isUnifiedPlanSupported;\n    }\n\n    // ios-hacks.js\n\n    function setCordovaAPIs() {\n        // if (DetectRTC.osName !== 'iOS') return;\n        if (typeof cordova === 'undefined' || typeof cordova.plugins === 'undefined' || typeof cordova.plugins.iosrtc === 'undefined') return;\n\n        var iosrtc = cordova.plugins.iosrtc;\n        window.webkitRTCPeerConnection = iosrtc.RTCPeerConnection;\n        window.RTCSessionDescription = iosrtc.RTCSessionDescription;\n        window.RTCIceCandidate = iosrtc.RTCIceCandidate;\n        window.MediaStream = iosrtc.MediaStream;\n        window.MediaStreamTrack = iosrtc.MediaStreamTrack;\n        navigator.getUserMedia = navigator.webkitGetUserMedia = iosrtc.getUserMedia;\n\n        iosrtc.debug.enable('iosrtc*');\n        if (typeof iosrtc.selectAudioOutput == 'function') {\n            iosrtc.selectAudioOutput(window.iOSDefaultAudioOutputDevice || 'speaker'); // earpiece or speaker\n        }\n        iosrtc.registerGlobals();\n    }\n\n    document.addEventListener('deviceready', setCordovaAPIs, false);\n    setCordovaAPIs();\n\n    // RTCPeerConnection.js\n\n    var defaults = {};\n\n    function setSdpConstraints(config) {\n        var sdpConstraints = {\n            OfferToReceiveAudio: !!config.OfferToReceiveAudio,\n            OfferToReceiveVideo: !!config.OfferToReceiveVideo\n        };\n\n        return sdpConstraints;\n    }\n\n    var RTCPeerConnection;\n    if (typeof window.RTCPeerConnection !== 'undefined') {\n        RTCPeerConnection = window.RTCPeerConnection;\n    } else if (typeof mozRTCPeerConnection !== 'undefined') {\n        RTCPeerConnection = mozRTCPeerConnection;\n    } else if (typeof webkitRTCPeerConnection !== 'undefined') {\n        RTCPeerConnection = webkitRTCPeerConnection;\n    }\n\n    var RTCSessionDescription = window.RTCSessionDescription || window.mozRTCSessionDescription;\n    var RTCIceCandidate = window.RTCIceCandidate || window.mozRTCIceCandidate;\n    var MediaStreamTrack = window.MediaStreamTrack;\n\n    function PeerInitiator(config) {\n        if (typeof window.RTCPeerConnection !== 'undefined') {\n            RTCPeerConnection = window.RTCPeerConnection;\n        } else if (typeof mozRTCPeerConnection !== 'undefined') {\n            RTCPeerConnection = mozRTCPeerConnection;\n        } else if (typeof webkitRTCPeerConnection !== 'undefined') {\n            RTCPeerConnection = webkitRTCPeerConnection;\n        }\n\n        RTCSessionDescription = window.RTCSessionDescription || window.mozRTCSessionDescription;\n        RTCIceCandidate = window.RTCIceCandidate || window.mozRTCIceCandidate;\n        MediaStreamTrack = window.MediaStreamTrack;\n\n        if (!RTCPeerConnection) {\n            throw 'WebRTC 1.0 (RTCPeerConnection) API are NOT available in this browser.';\n        }\n\n        var connection = config.rtcMultiConnection;\n\n        this.extra = config.remoteSdp ? config.remoteSdp.extra : connection.extra;\n        this.userid = config.userid;\n        this.streams = [];\n        this.channels = config.channels || [];\n        this.connectionDescription = config.connectionDescription;\n\n        this.addStream = function(session) {\n            connection.addStream(session, self.userid);\n        };\n\n        this.removeStream = function(streamid) {\n            connection.removeStream(streamid, self.userid);\n        };\n\n        var self = this;\n\n        if (config.remoteSdp) {\n            this.connectionDescription = config.remoteSdp.connectionDescription;\n        }\n\n        var allRemoteStreams = {};\n\n        defaults.sdpConstraints = setSdpConstraints({\n            OfferToReceiveAudio: true,\n            OfferToReceiveVideo: true\n        });\n\n        var peer;\n\n        var renegotiatingPeer = !!config.renegotiatingPeer;\n        if (config.remoteSdp) {\n            renegotiatingPeer = !!config.remoteSdp.renegotiatingPeer;\n        }\n\n        var localStreams = [];\n        connection.attachStreams.forEach(function(stream) {\n            if (!!stream) {\n                localStreams.push(stream);\n            }\n        });\n\n        if (!renegotiatingPeer) {\n            var iceTransports = 'all';\n            if (connection.candidates.turn || connection.candidates.relay) {\n                if (!connection.candidates.stun && !connection.candidates.reflexive && !connection.candidates.host) {\n                    iceTransports = 'relay';\n                }\n            }\n\n            try {\n                // ref: developer.mozilla.org/en-US/docs/Web/API/RTCConfiguration\n                var params = {\n                    iceServers: connection.iceServers,\n                    iceTransportPolicy: connection.iceTransportPolicy || iceTransports\n                };\n\n                if (typeof connection.iceCandidatePoolSize !== 'undefined') {\n                    params.iceCandidatePoolSize = connection.iceCandidatePoolSize;\n                }\n\n                if (typeof connection.bundlePolicy !== 'undefined') {\n                    params.bundlePolicy = connection.bundlePolicy;\n                }\n\n                if (typeof connection.rtcpMuxPolicy !== 'undefined') {\n                    params.rtcpMuxPolicy = connection.rtcpMuxPolicy;\n                }\n\n                if (!!connection.sdpSemantics) {\n                    params.sdpSemantics = connection.sdpSemantics || 'unified-plan';\n                }\n\n                if (!connection.iceServers || !connection.iceServers.length) {\n                    params = null;\n                    connection.optionalArgument = null;\n                }\n\n                peer = new RTCPeerConnection(params, connection.optionalArgument);\n            } catch (e) {\n                try {\n                    var params = {\n                        iceServers: connection.iceServers\n                    };\n\n                    peer = new RTCPeerConnection(params);\n                } catch (e) {\n                    peer = new RTCPeerConnection();\n                }\n            }\n        } else {\n            peer = config.peerRef;\n        }\n\n        if (!peer.getRemoteStreams && peer.getReceivers) {\n            peer.getRemoteStreams = function() {\n                var stream = new MediaStream();\n                peer.getReceivers().forEach(function(receiver) {\n                    stream.addTrack(receiver.track);\n                });\n                return [stream];\n            };\n        }\n\n        if (!peer.getLocalStreams && peer.getSenders) {\n            peer.getLocalStreams = function() {\n                var stream = new MediaStream();\n                peer.getSenders().forEach(function(sender) {\n                    stream.addTrack(sender.track);\n                });\n                return [stream];\n            };\n        }\n\n        peer.onicecandidate = function(event) {\n            if (!event.candidate) {\n                if (!connection.trickleIce) {\n                    var localSdp = peer.localDescription;\n                    config.onLocalSdp({\n                        type: localSdp.type,\n                        sdp: localSdp.sdp,\n                        remotePeerSdpConstraints: config.remotePeerSdpConstraints || false,\n                        renegotiatingPeer: !!config.renegotiatingPeer || false,\n                        connectionDescription: self.connectionDescription,\n                        dontGetRemoteStream: !!config.dontGetRemoteStream,\n                        extra: connection ? connection.extra : {},\n                        streamsToShare: streamsToShare\n                    });\n                }\n                return;\n            }\n\n            if (!connection.trickleIce) return;\n            config.onLocalCandidate({\n                candidate: event.candidate.candidate,\n                sdpMid: event.candidate.sdpMid,\n                sdpMLineIndex: event.candidate.sdpMLineIndex\n            });\n        };\n\n        localStreams.forEach(function(localStream) {\n            if (config.remoteSdp && config.remoteSdp.remotePeerSdpConstraints && config.remoteSdp.remotePeerSdpConstraints.dontGetRemoteStream) {\n                return;\n            }\n\n            if (config.dontAttachLocalStream) {\n                return;\n            }\n\n            localStream = connection.beforeAddingStream(localStream, self);\n\n            if (!localStream) return;\n\n            peer.getLocalStreams().forEach(function(stream) {\n                if (localStream && stream.id == localStream.id) {\n                    localStream = null;\n                }\n            });\n\n            if (localStream && localStream.getTracks) {\n                localStream.getTracks().forEach(function(track) {\n                    try {\n                        // last parameter is redundant for unified-plan\n                        // starting from chrome version 72\n                        peer.addTrack(track, localStream);\n                    } catch (e) {}\n                });\n            }\n        });\n\n        peer.oniceconnectionstatechange = peer.onsignalingstatechange = function() {\n            var extra = self.extra;\n            if (connection.peers[self.userid]) {\n                extra = connection.peers[self.userid].extra || extra;\n            }\n\n            if (!peer) {\n                return;\n            }\n\n            config.onPeerStateChanged({\n                iceConnectionState: peer.iceConnectionState,\n                iceGatheringState: peer.iceGatheringState,\n                signalingState: peer.signalingState,\n                extra: extra,\n                userid: self.userid\n            });\n\n            if (peer && peer.iceConnectionState && peer.iceConnectionState.search(/closed|failed/gi) !== -1 && self.streams instanceof Array) {\n                self.streams.forEach(function(stream) {\n                    var streamEvent = connection.streamEvents[stream.id] || {\n                        streamid: stream.id,\n                        stream: stream,\n                        type: 'remote'\n                    };\n\n                    connection.onstreamended(streamEvent);\n                });\n            }\n        };\n\n        var sdpConstraints = {\n            OfferToReceiveAudio: !!localStreams.length,\n            OfferToReceiveVideo: !!localStreams.length\n        };\n\n        if (config.localPeerSdpConstraints) sdpConstraints = config.localPeerSdpConstraints;\n\n        defaults.sdpConstraints = setSdpConstraints(sdpConstraints);\n\n        var streamObject;\n        var dontDuplicate = {};\n\n        peer.ontrack = function(event) {\n            if (!event || event.type !== 'track') return;\n\n            event.stream = event.streams[event.streams.length - 1];\n\n            if (!event.stream.id) {\n                event.stream.id = event.track.id;\n            }\n\n            if (dontDuplicate[event.stream.id] && DetectRTC.browser.name !== 'Safari') {\n                if (event.track) {\n                    event.track.onended = function() { // event.track.onmute = \n                        peer && peer.onremovestream(event);\n                    };\n                }\n                return;\n            }\n\n            dontDuplicate[event.stream.id] = event.stream.id;\n\n            var streamsToShare = {};\n            if (config.remoteSdp && config.remoteSdp.streamsToShare) {\n                streamsToShare = config.remoteSdp.streamsToShare;\n            } else if (config.streamsToShare) {\n                streamsToShare = config.streamsToShare;\n            }\n\n            var streamToShare = streamsToShare[event.stream.id];\n            if (streamToShare) {\n                event.stream.isAudio = streamToShare.isAudio;\n                event.stream.isVideo = streamToShare.isVideo;\n                event.stream.isScreen = streamToShare.isScreen;\n            } else {\n                event.stream.isVideo = !!getTracks(event.stream, 'video').length;\n                event.stream.isAudio = !event.stream.isVideo;\n                event.stream.isScreen = false;\n            }\n\n            event.stream.streamid = event.stream.id;\n\n            allRemoteStreams[event.stream.id] = event.stream;\n            config.onRemoteStream(event.stream);\n\n            event.stream.getTracks().forEach(function(track) {\n                track.onended = function() { // track.onmute = \n                    peer && peer.onremovestream(event);\n                };\n            });\n\n            event.stream.onremovetrack = function() {\n                peer && peer.onremovestream(event);\n            };\n        };\n\n        peer.onremovestream = function(event) {\n            // this event doesn't works anymore\n            event.stream.streamid = event.stream.id;\n\n            if (allRemoteStreams[event.stream.id]) {\n                delete allRemoteStreams[event.stream.id];\n            }\n\n            config.onRemoteStreamRemoved(event.stream);\n        };\n\n        if (typeof peer.removeStream !== 'function') {\n            // removeStream backward compatibility\n            peer.removeStream = function(stream) {\n                stream.getTracks().forEach(function(track) {\n                    peer.removeTrack(track, stream);\n                });\n            };\n        }\n\n        this.addRemoteCandidate = function(remoteCandidate) {\n            peer.addIceCandidate(new RTCIceCandidate(remoteCandidate));\n        };\n\n        function oldAddRemoteSdp(remoteSdp, cb) {\n            cb = cb || function() {};\n\n            if (DetectRTC.browser.name !== 'Safari') {\n                remoteSdp.sdp = connection.processSdp(remoteSdp.sdp);\n            }\n            peer.setRemoteDescription(new RTCSessionDescription(remoteSdp), cb, function(error) {\n                if (!!connection.enableLogs) {\n                    console.error('setRemoteDescription failed', '\\n', error, '\\n', remoteSdp.sdp);\n                }\n\n                cb();\n            });\n        }\n\n        this.addRemoteSdp = function(remoteSdp, cb) {\n            cb = cb || function() {};\n\n            if (DetectRTC.browser.name !== 'Safari') {\n                remoteSdp.sdp = connection.processSdp(remoteSdp.sdp);\n            }\n\n            peer.setRemoteDescription(new RTCSessionDescription(remoteSdp)).then(cb, function(error) {\n                if (!!connection.enableLogs) {\n                    console.error('setRemoteDescription failed', '\\n', error, '\\n', remoteSdp.sdp);\n                }\n\n                cb();\n            }).catch(function(error) {\n                if (!!connection.enableLogs) {\n                    console.error('setRemoteDescription failed', '\\n', error, '\\n', remoteSdp.sdp);\n                }\n\n                cb();\n            });\n        };\n\n        var isOfferer = true;\n\n        if (config.remoteSdp) {\n            isOfferer = false;\n        }\n\n        this.createDataChannel = function() {\n            var channel = peer.createDataChannel('sctp', {});\n            setChannelEvents(channel);\n        };\n\n        if (connection.session.data === true && !renegotiatingPeer) {\n            if (!isOfferer) {\n                peer.ondatachannel = function(event) {\n                    var channel = event.channel;\n                    setChannelEvents(channel);\n                };\n            } else {\n                this.createDataChannel();\n            }\n        }\n\n        this.enableDisableVideoEncoding = function(enable) {\n            var rtcp;\n            peer.getSenders().forEach(function(sender) {\n                if (!rtcp && sender.track.kind === 'video') {\n                    rtcp = sender;\n                }\n            });\n\n            if (!rtcp || !rtcp.getParameters) return;\n\n            var parameters = rtcp.getParameters();\n            parameters.encodings[1] && (parameters.encodings[1].active = !!enable);\n            parameters.encodings[2] && (parameters.encodings[2].active = !!enable);\n            rtcp.setParameters(parameters);\n        };\n\n        if (config.remoteSdp) {\n            if (config.remoteSdp.remotePeerSdpConstraints) {\n                sdpConstraints = config.remoteSdp.remotePeerSdpConstraints;\n            }\n            defaults.sdpConstraints = setSdpConstraints(sdpConstraints);\n            this.addRemoteSdp(config.remoteSdp, function() {\n                createOfferOrAnswer('createAnswer');\n            });\n        }\n\n        function setChannelEvents(channel) {\n            // force ArrayBuffer in Firefox; which uses \"Blob\" by default.\n            channel.binaryType = 'arraybuffer';\n\n            channel.onmessage = function(event) {\n                config.onDataChannelMessage(event.data);\n            };\n\n            channel.onopen = function() {\n                config.onDataChannelOpened(channel);\n            };\n\n            channel.onerror = function(error) {\n                config.onDataChannelError(error);\n            };\n\n            channel.onclose = function(event) {\n                config.onDataChannelClosed(event);\n            };\n\n            channel.internalSend = channel.send;\n            channel.send = function(data) {\n                if (channel.readyState !== 'open') {\n                    return;\n                }\n\n                channel.internalSend(data);\n            };\n\n            peer.channel = channel;\n        }\n\n        if (connection.session.audio == 'two-way' || connection.session.video == 'two-way' || connection.session.screen == 'two-way') {\n            defaults.sdpConstraints = setSdpConstraints({\n                OfferToReceiveAudio: connection.session.audio == 'two-way' || (config.remoteSdp && config.remoteSdp.remotePeerSdpConstraints && config.remoteSdp.remotePeerSdpConstraints.OfferToReceiveAudio),\n                OfferToReceiveVideo: connection.session.video == 'two-way' || connection.session.screen == 'two-way' || (config.remoteSdp && config.remoteSdp.remotePeerSdpConstraints && config.remoteSdp.remotePeerSdpConstraints.OfferToReceiveAudio)\n            });\n        }\n\n        var streamsToShare = {};\n        peer.getLocalStreams().forEach(function(stream) {\n            streamsToShare[stream.streamid] = {\n                isAudio: !!stream.isAudio,\n                isVideo: !!stream.isVideo,\n                isScreen: !!stream.isScreen\n            };\n        });\n\n        function oldCreateOfferOrAnswer(_method) {\n            peer[_method](function(localSdp) {\n                if (DetectRTC.browser.name !== 'Safari') {\n                    localSdp.sdp = connection.processSdp(localSdp.sdp);\n                }\n                peer.setLocalDescription(localSdp, function() {\n                    if (!connection.trickleIce) return;\n\n                    config.onLocalSdp({\n                        type: localSdp.type,\n                        sdp: localSdp.sdp,\n                        remotePeerSdpConstraints: config.remotePeerSdpConstraints || false,\n                        renegotiatingPeer: !!config.renegotiatingPeer || false,\n                        connectionDescription: self.connectionDescription,\n                        dontGetRemoteStream: !!config.dontGetRemoteStream,\n                        extra: connection ? connection.extra : {},\n                        streamsToShare: streamsToShare\n                    });\n\n                    connection.onSettingLocalDescription(self);\n                }, function(error) {\n                    if (!!connection.enableLogs) {\n                        console.error('setLocalDescription-error', error);\n                    }\n                });\n            }, function(error) {\n                if (!!connection.enableLogs) {\n                    console.error('sdp-' + _method + '-error', error);\n                }\n            }, defaults.sdpConstraints);\n        }\n\n        function createOfferOrAnswer(_method) {\n            peer[_method](defaults.sdpConstraints).then(function(localSdp) {\n                if (DetectRTC.browser.name !== 'Safari') {\n                    localSdp.sdp = connection.processSdp(localSdp.sdp);\n                }\n                peer.setLocalDescription(localSdp).then(function() {\n                    if (!connection.trickleIce) return;\n\n                    config.onLocalSdp({\n                        type: localSdp.type,\n                        sdp: localSdp.sdp,\n                        remotePeerSdpConstraints: config.remotePeerSdpConstraints || false,\n                        renegotiatingPeer: !!config.renegotiatingPeer || false,\n                        connectionDescription: self.connectionDescription,\n                        dontGetRemoteStream: !!config.dontGetRemoteStream,\n                        extra: connection ? connection.extra : {},\n                        streamsToShare: streamsToShare\n                    });\n\n                    connection.onSettingLocalDescription(self);\n                }, function(error) {\n                    if (!connection.enableLogs) return;\n                    console.error('setLocalDescription error', error);\n                });\n            }, function(error) {\n                if (!!connection.enableLogs) {\n                    console.error('sdp-error', error);\n                }\n            });\n        }\n\n        if (isOfferer) {\n            createOfferOrAnswer('createOffer');\n        }\n\n        peer.nativeClose = peer.close;\n        peer.close = function() {\n            if (!peer) {\n                return;\n            }\n\n            try {\n                if (peer.nativeClose !== peer.close) {\n                    peer.nativeClose();\n                }\n            } catch (e) {}\n\n            peer = null;\n            self.peer = null;\n        };\n\n        this.peer = peer;\n    }\n\n    // CodecsHandler.js\n\n    var CodecsHandler = (function() {\n        function preferCodec(sdp, codecName) {\n            var info = splitLines(sdp);\n\n            if (!info.videoCodecNumbers) {\n                return sdp;\n            }\n\n            if (codecName === 'vp8' && info.vp8LineNumber === info.videoCodecNumbers[0]) {\n                return sdp;\n            }\n\n            if (codecName === 'vp9' && info.vp9LineNumber === info.videoCodecNumbers[0]) {\n                return sdp;\n            }\n\n            if (codecName === 'h264' && info.h264LineNumber === info.videoCodecNumbers[0]) {\n                return sdp;\n            }\n\n            sdp = preferCodecHelper(sdp, codecName, info);\n\n            return sdp;\n        }\n\n        function preferCodecHelper(sdp, codec, info, ignore) {\n            var preferCodecNumber = '';\n\n            if (codec === 'vp8') {\n                if (!info.vp8LineNumber) {\n                    return sdp;\n                }\n                preferCodecNumber = info.vp8LineNumber;\n            }\n\n            if (codec === 'vp9') {\n                if (!info.vp9LineNumber) {\n                    return sdp;\n                }\n                preferCodecNumber = info.vp9LineNumber;\n            }\n\n            if (codec === 'h264') {\n                if (!info.h264LineNumber) {\n                    return sdp;\n                }\n\n                preferCodecNumber = info.h264LineNumber;\n            }\n\n            var newLine = info.videoCodecNumbersOriginal.split('SAVPF')[0] + 'SAVPF ';\n\n            var newOrder = [preferCodecNumber];\n\n            if (ignore) {\n                newOrder = [];\n            }\n\n            info.videoCodecNumbers.forEach(function(codecNumber) {\n                if (codecNumber === preferCodecNumber) return;\n                newOrder.push(codecNumber);\n            });\n\n            newLine += newOrder.join(' ');\n\n            sdp = sdp.replace(info.videoCodecNumbersOriginal, newLine);\n            return sdp;\n        }\n\n        function splitLines(sdp) {\n            var info = {};\n            sdp.split('\\n').forEach(function(line) {\n                if (line.indexOf('m=video') === 0) {\n                    info.videoCodecNumbers = [];\n                    line.split('SAVPF')[1].split(' ').forEach(function(codecNumber) {\n                        codecNumber = codecNumber.trim();\n                        if (!codecNumber || !codecNumber.length) return;\n                        info.videoCodecNumbers.push(codecNumber);\n                        info.videoCodecNumbersOriginal = line;\n                    });\n                }\n\n                if (line.indexOf('VP8/90000') !== -1 && !info.vp8LineNumber) {\n                    info.vp8LineNumber = line.replace('a=rtpmap:', '').split(' ')[0];\n                }\n\n                if (line.indexOf('VP9/90000') !== -1 && !info.vp9LineNumber) {\n                    info.vp9LineNumber = line.replace('a=rtpmap:', '').split(' ')[0];\n                }\n\n                if (line.indexOf('H264/90000') !== -1 && !info.h264LineNumber) {\n                    info.h264LineNumber = line.replace('a=rtpmap:', '').split(' ')[0];\n                }\n            });\n\n            return info;\n        }\n\n        function removeVPX(sdp) {\n            var info = splitLines(sdp);\n\n            // last parameter below means: ignore these codecs\n            sdp = preferCodecHelper(sdp, 'vp9', info, true);\n            sdp = preferCodecHelper(sdp, 'vp8', info, true);\n\n            return sdp;\n        }\n\n        function disableNACK(sdp) {\n            if (!sdp || typeof sdp !== 'string') {\n                throw 'Invalid arguments.';\n            }\n\n            sdp = sdp.replace('a=rtcp-fb:126 nack\\r\\n', '');\n            sdp = sdp.replace('a=rtcp-fb:126 nack pli\\r\\n', 'a=rtcp-fb:126 pli\\r\\n');\n            sdp = sdp.replace('a=rtcp-fb:97 nack\\r\\n', '');\n            sdp = sdp.replace('a=rtcp-fb:97 nack pli\\r\\n', 'a=rtcp-fb:97 pli\\r\\n');\n\n            return sdp;\n        }\n\n        function prioritize(codecMimeType, peer) {\n            if (!peer || !peer.getSenders || !peer.getSenders().length) {\n                return;\n            }\n\n            if (!codecMimeType || typeof codecMimeType !== 'string') {\n                throw 'Invalid arguments.';\n            }\n\n            peer.getSenders().forEach(function(sender) {\n                var params = sender.getParameters();\n                for (var i = 0; i < params.codecs.length; i++) {\n                    if (params.codecs[i].mimeType == codecMimeType) {\n                        params.codecs.unshift(params.codecs.splice(i, 1));\n                        break;\n                    }\n                }\n                sender.setParameters(params);\n            });\n        }\n\n        function removeNonG722(sdp) {\n            return sdp.replace(/m=audio ([0-9]+) RTP\\/SAVPF ([0-9 ]*)/g, 'm=audio $1 RTP\\/SAVPF 9');\n        }\n\n        function setBAS(sdp, bandwidth, isScreen) {\n            if (!bandwidth) {\n                return sdp;\n            }\n\n            if (typeof isFirefox !== 'undefined' && isFirefox) {\n                return sdp;\n            }\n\n            if (isScreen) {\n                if (!bandwidth.screen) {\n                    console.warn('It seems that you are not using bandwidth for screen. Screen sharing is expected to fail.');\n                } else if (bandwidth.screen < 300) {\n                    console.warn('It seems that you are using wrong bandwidth value for screen. Screen sharing is expected to fail.');\n                }\n            }\n\n            // if screen; must use at least 300kbs\n            if (bandwidth.screen && isScreen) {\n                sdp = sdp.replace(/b=AS([^\\r\\n]+\\r\\n)/g, '');\n                sdp = sdp.replace(/a=mid:video\\r\\n/g, 'a=mid:video\\r\\nb=AS:' + bandwidth.screen + '\\r\\n');\n            }\n\n            // remove existing bandwidth lines\n            if (bandwidth.audio || bandwidth.video) {\n                sdp = sdp.replace(/b=AS([^\\r\\n]+\\r\\n)/g, '');\n            }\n\n            if (bandwidth.audio) {\n                sdp = sdp.replace(/a=mid:audio\\r\\n/g, 'a=mid:audio\\r\\nb=AS:' + bandwidth.audio + '\\r\\n');\n            }\n\n            if (bandwidth.screen) {\n                sdp = sdp.replace(/a=mid:video\\r\\n/g, 'a=mid:video\\r\\nb=AS:' + bandwidth.screen + '\\r\\n');\n            } else if (bandwidth.video) {\n                sdp = sdp.replace(/a=mid:video\\r\\n/g, 'a=mid:video\\r\\nb=AS:' + bandwidth.video + '\\r\\n');\n            }\n\n            return sdp;\n        }\n\n        // Find the line in sdpLines that starts with |prefix|, and, if specified,\n        // contains |substr| (case-insensitive search).\n        function findLine(sdpLines, prefix, substr) {\n            return findLineInRange(sdpLines, 0, -1, prefix, substr);\n        }\n\n        // Find the line in sdpLines[startLine...endLine - 1] that starts with |prefix|\n        // and, if specified, contains |substr| (case-insensitive search).\n        function findLineInRange(sdpLines, startLine, endLine, prefix, substr) {\n            var realEndLine = endLine !== -1 ? endLine : sdpLines.length;\n            for (var i = startLine; i < realEndLine; ++i) {\n                if (sdpLines[i].indexOf(prefix) === 0) {\n                    if (!substr ||\n                        sdpLines[i].toLowerCase().indexOf(substr.toLowerCase()) !== -1) {\n                        return i;\n                    }\n                }\n            }\n            return null;\n        }\n\n        // Gets the codec payload type from an a=rtpmap:X line.\n        function getCodecPayloadType(sdpLine) {\n            var pattern = new RegExp('a=rtpmap:(\\\\d+) \\\\w+\\\\/\\\\d+');\n            var result = sdpLine.match(pattern);\n            return (result && result.length === 2) ? result[1] : null;\n        }\n\n        function setVideoBitrates(sdp, params) {\n            params = params || {};\n            var xgoogle_min_bitrate = params.min;\n            var xgoogle_max_bitrate = params.max;\n\n            var sdpLines = sdp.split('\\r\\n');\n\n            // VP8\n            var vp8Index = findLine(sdpLines, 'a=rtpmap', 'VP8/90000');\n            var vp8Payload;\n            if (vp8Index) {\n                vp8Payload = getCodecPayloadType(sdpLines[vp8Index]);\n            }\n\n            if (!vp8Payload) {\n                return sdp;\n            }\n\n            var rtxIndex = findLine(sdpLines, 'a=rtpmap', 'rtx/90000');\n            var rtxPayload;\n            if (rtxIndex) {\n                rtxPayload = getCodecPayloadType(sdpLines[rtxIndex]);\n            }\n\n            if (!rtxIndex) {\n                return sdp;\n            }\n\n            var rtxFmtpLineIndex = findLine(sdpLines, 'a=fmtp:' + rtxPayload.toString());\n            if (rtxFmtpLineIndex !== null) {\n                var appendrtxNext = '\\r\\n';\n                appendrtxNext += 'a=fmtp:' + vp8Payload + ' x-google-min-bitrate=' + (xgoogle_min_bitrate || '228') + '; x-google-max-bitrate=' + (xgoogle_max_bitrate || '228');\n                sdpLines[rtxFmtpLineIndex] = sdpLines[rtxFmtpLineIndex].concat(appendrtxNext);\n                sdp = sdpLines.join('\\r\\n');\n            }\n\n            return sdp;\n        }\n\n        function setOpusAttributes(sdp, params) {\n            params = params || {};\n\n            var sdpLines = sdp.split('\\r\\n');\n\n            // Opus\n            var opusIndex = findLine(sdpLines, 'a=rtpmap', 'opus/48000');\n            var opusPayload;\n            if (opusIndex) {\n                opusPayload = getCodecPayloadType(sdpLines[opusIndex]);\n            }\n\n            if (!opusPayload) {\n                return sdp;\n            }\n\n            var opusFmtpLineIndex = findLine(sdpLines, 'a=fmtp:' + opusPayload.toString());\n            if (opusFmtpLineIndex === null) {\n                return sdp;\n            }\n\n            var appendOpusNext = '';\n            appendOpusNext += '; stereo=' + (typeof params.stereo != 'undefined' ? params.stereo : '1');\n            appendOpusNext += '; sprop-stereo=' + (typeof params['sprop-stereo'] != 'undefined' ? params['sprop-stereo'] : '1');\n\n            if (typeof params.maxaveragebitrate != 'undefined') {\n                appendOpusNext += '; maxaveragebitrate=' + (params.maxaveragebitrate || 128 * 1024 * 8);\n            }\n\n            if (typeof params.maxplaybackrate != 'undefined') {\n                appendOpusNext += '; maxplaybackrate=' + (params.maxplaybackrate || 128 * 1024 * 8);\n            }\n\n            if (typeof params.cbr != 'undefined') {\n                appendOpusNext += '; cbr=' + (typeof params.cbr != 'undefined' ? params.cbr : '1');\n            }\n\n            if (typeof params.useinbandfec != 'undefined') {\n                appendOpusNext += '; useinbandfec=' + params.useinbandfec;\n            }\n\n            if (typeof params.usedtx != 'undefined') {\n                appendOpusNext += '; usedtx=' + params.usedtx;\n            }\n\n            if (typeof params.maxptime != 'undefined') {\n                appendOpusNext += '\\r\\na=maxptime:' + params.maxptime;\n            }\n\n            sdpLines[opusFmtpLineIndex] = sdpLines[opusFmtpLineIndex].concat(appendOpusNext);\n\n            sdp = sdpLines.join('\\r\\n');\n            return sdp;\n        }\n\n        // forceStereoAudio => via webrtcexample.com\n        // requires getUserMedia => echoCancellation:false\n        function forceStereoAudio(sdp) {\n            var sdpLines = sdp.split('\\r\\n');\n            var fmtpLineIndex = null;\n            for (var i = 0; i < sdpLines.length; i++) {\n                if (sdpLines[i].search('opus/48000') !== -1) {\n                    var opusPayload = extractSdp(sdpLines[i], /:(\\d+) opus\\/48000/i);\n                    break;\n                }\n            }\n            for (var i = 0; i < sdpLines.length; i++) {\n                if (sdpLines[i].search('a=fmtp') !== -1) {\n                    var payload = extractSdp(sdpLines[i], /a=fmtp:(\\d+)/);\n                    if (payload === opusPayload) {\n                        fmtpLineIndex = i;\n                        break;\n                    }\n                }\n            }\n            if (fmtpLineIndex === null) return sdp;\n            sdpLines[fmtpLineIndex] = sdpLines[fmtpLineIndex].concat('; stereo=1; sprop-stereo=1');\n            sdp = sdpLines.join('\\r\\n');\n            return sdp;\n        }\n\n        return {\n            removeVPX: removeVPX,\n            disableNACK: disableNACK,\n            prioritize: prioritize,\n            removeNonG722: removeNonG722,\n            setApplicationSpecificBandwidth: function(sdp, bandwidth, isScreen) {\n                return setBAS(sdp, bandwidth, isScreen);\n            },\n            setVideoBitrates: function(sdp, params) {\n                return setVideoBitrates(sdp, params);\n            },\n            setOpusAttributes: function(sdp, params) {\n                return setOpusAttributes(sdp, params);\n            },\n            preferVP9: function(sdp) {\n                return preferCodec(sdp, 'vp9');\n            },\n            preferCodec: preferCodec,\n            forceStereoAudio: forceStereoAudio\n        };\n    })();\n\n    // backward compatibility\n    window.BandwidthHandler = CodecsHandler;\n\n    // OnIceCandidateHandler.js\n\n    var OnIceCandidateHandler = (function() {\n        function processCandidates(connection, icePair) {\n            var candidate = icePair.candidate;\n\n            var iceRestrictions = connection.candidates;\n            var stun = iceRestrictions.stun;\n            var turn = iceRestrictions.turn;\n\n            if (!isNull(iceRestrictions.reflexive)) {\n                stun = iceRestrictions.reflexive;\n            }\n\n            if (!isNull(iceRestrictions.relay)) {\n                turn = iceRestrictions.relay;\n            }\n\n            if (!iceRestrictions.host && !!candidate.match(/typ host/g)) {\n                return;\n            }\n\n            if (!turn && !!candidate.match(/typ relay/g)) {\n                return;\n            }\n\n            if (!stun && !!candidate.match(/typ srflx/g)) {\n                return;\n            }\n\n            var protocol = connection.iceProtocols;\n\n            if (!protocol.udp && !!candidate.match(/ udp /g)) {\n                return;\n            }\n\n            if (!protocol.tcp && !!candidate.match(/ tcp /g)) {\n                return;\n            }\n\n            if (connection.enableLogs) {\n                console.debug('Your candidate pairs:', candidate);\n            }\n\n            return {\n                candidate: candidate,\n                sdpMid: icePair.sdpMid,\n                sdpMLineIndex: icePair.sdpMLineIndex\n            };\n        }\n\n        return {\n            processCandidates: processCandidates\n        };\n    })();\n\n    // IceServersHandler.js\n\n    var IceServersHandler = (function() {\n        function getIceServers(connection) {\n            // resiprocate: 3344+4433\n            // pions: 7575\n            var iceServers = [{\n                    'urls': [\n                        'stun:webrtcweb.com:7788'\n                    ],\n                    'username': 'muazkh',\n                    'credential': 'muazkh'\n                },\n                {\n                    'urls': [\n                        'turn:webrtcweb.com:7788', // coTURN 7788+8877\n                        'turn:webrtcweb.com:8877',\n                        'turn:webrtcweb.com:4455', // restund udp\n                    ],\n                    'username': 'muazkh',\n                    'credential': 'muazkh'\n                },\n                {\n                    'urls': [\n                        'stun:stun.l.google.com:19302',\n                        'stun:stun1.l.google.com:19302',\n                        'stun:stun2.l.google.com:19302',\n                        'stun:stun.l.google.com:19302?transport=udp',\n                    ]\n                }\n            ];\n\n            return iceServers;\n        }\n\n        return {\n            getIceServers: getIceServers\n        };\n    })();\n\n    // getUserMediaHandler.js\n\n    function setStreamType(constraints, stream) {\n        if (constraints.mandatory && constraints.mandatory.chromeMediaSource) {\n            stream.isScreen = true;\n        } else if (constraints.mozMediaSource || constraints.mediaSource) {\n            stream.isScreen = true;\n        } else if (constraints.video) {\n            stream.isVideo = true;\n        } else if (constraints.audio) {\n            stream.isAudio = true;\n        }\n    }\n\n    // allow users to manage this object (to support re-capturing of screen/etc.)\n    window.currentUserMediaRequest = {\n        streams: [],\n        mutex: false,\n        queueRequests: [],\n        remove: function(idInstance) {\n            this.mutex = false;\n\n            var stream = this.streams[idInstance];\n            if (!stream) {\n                return;\n            }\n\n            stream = stream.stream;\n\n            var options = stream.currentUserMediaRequestOptions;\n\n            if (this.queueRequests.indexOf(options)) {\n                delete this.queueRequests[this.queueRequests.indexOf(options)];\n                this.queueRequests = removeNullEntries(this.queueRequests);\n            }\n\n            this.streams[idInstance].stream = null;\n            delete this.streams[idInstance];\n        }\n    };\n\n    function getUserMediaHandler(options) {\n        if (currentUserMediaRequest.mutex === true) {\n            currentUserMediaRequest.queueRequests.push(options);\n            return;\n        }\n        currentUserMediaRequest.mutex = true;\n\n        // easy way to match\n        var idInstance = JSON.stringify(options.localMediaConstraints);\n\n        function streaming(stream, returnBack) {\n            setStreamType(options.localMediaConstraints, stream);\n\n            var streamEndedEvent = 'ended';\n\n            if ('oninactive' in stream) {\n                streamEndedEvent = 'inactive';\n            }\n            stream.addEventListener(streamEndedEvent, function() {\n                delete currentUserMediaRequest.streams[idInstance];\n\n                currentUserMediaRequest.mutex = false;\n                if (currentUserMediaRequest.queueRequests.indexOf(options)) {\n                    delete currentUserMediaRequest.queueRequests[currentUserMediaRequest.queueRequests.indexOf(options)];\n                    currentUserMediaRequest.queueRequests = removeNullEntries(currentUserMediaRequest.queueRequests);\n                }\n            }, false);\n\n            currentUserMediaRequest.streams[idInstance] = {\n                stream: stream\n            };\n            currentUserMediaRequest.mutex = false;\n\n            if (currentUserMediaRequest.queueRequests.length) {\n                getUserMediaHandler(currentUserMediaRequest.queueRequests.shift());\n            }\n\n            // callback\n            options.onGettingLocalMedia(stream, returnBack);\n        }\n\n        if (currentUserMediaRequest.streams[idInstance]) {\n            streaming(currentUserMediaRequest.streams[idInstance].stream, true);\n        } else {\n            var isBlackBerry = !!(/BB10|BlackBerry/i.test(navigator.userAgent || ''));\n            if (isBlackBerry || typeof navigator.mediaDevices === 'undefined' || typeof navigator.mediaDevices.getUserMedia !== 'function') {\n                navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia;\n                navigator.getUserMedia(options.localMediaConstraints, function(stream) {\n                    stream.streamid = stream.streamid || stream.id || getRandomString();\n                    stream.idInstance = idInstance;\n                    streaming(stream);\n                }, function(error) {\n                    options.onLocalMediaError(error, options.localMediaConstraints);\n                });\n                return;\n            }\n\n            if (typeof navigator.mediaDevices === 'undefined') {\n                navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia;\n                var getUserMediaSuccess = function() {};\n                var getUserMediaFailure = function() {};\n\n                var getUserMediaStream, getUserMediaError;\n                navigator.mediaDevices = {\n                    getUserMedia: function(hints) {\n                        navigator.getUserMedia(hints, function(getUserMediaSuccess) {\n                            getUserMediaSuccess(stream);\n                            getUserMediaStream = stream;\n                        }, function(error) {\n                            getUserMediaFailure(error);\n                            getUserMediaError = error;\n                        });\n\n                        return {\n                            then: function(successCB) {\n                                if (getUserMediaStream) {\n                                    successCB(getUserMediaStream);\n                                    return;\n                                }\n\n                                getUserMediaSuccess = successCB;\n\n                                return {\n                                    then: function(failureCB) {\n                                        if (getUserMediaError) {\n                                            failureCB(getUserMediaError);\n                                            return;\n                                        }\n\n                                        getUserMediaFailure = failureCB;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                };\n            }\n\n            navigator.mediaDevices.getUserMedia(options.localMediaConstraints).then(function(stream) {\n                stream.streamid = stream.streamid || stream.id || getRandomString();\n                stream.idInstance = idInstance;\n\n                streaming(stream);\n            }).catch(function(error) {\n                options.onLocalMediaError(error, options.localMediaConstraints);\n            });\n        }\n    }\n\n    // StreamsHandler.js\n\n    var StreamsHandler = (function() {\n        function handleType(type) {\n            if (!type) {\n                return;\n            }\n\n            if (typeof type === 'string' || typeof type === 'undefined') {\n                return type;\n            }\n\n            if (type.audio && type.video) {\n                return null;\n            }\n\n            if (type.audio) {\n                return 'audio';\n            }\n\n            if (type.video) {\n                return 'video';\n            }\n\n            return;\n        }\n\n        function setHandlers(stream, syncAction, connection) {\n            if (!stream || !stream.addEventListener) return;\n\n            if (typeof syncAction == 'undefined' || syncAction == true) {\n                var streamEndedEvent = 'ended';\n\n                if ('oninactive' in stream) {\n                    streamEndedEvent = 'inactive';\n                }\n\n                stream.addEventListener(streamEndedEvent, function() {\n                    StreamsHandler.onSyncNeeded(this.streamid, streamEndedEvent);\n                }, false);\n            }\n\n            stream.mute = function(type, isSyncAction) {\n                type = handleType(type);\n\n                if (typeof isSyncAction !== 'undefined') {\n                    syncAction = isSyncAction;\n                }\n\n                if (typeof type == 'undefined' || type == 'audio') {\n                    getTracks(stream, 'audio').forEach(function(track) {\n                        track.enabled = false;\n                        connection.streamEvents[stream.streamid].isAudioMuted = true;\n                    });\n                }\n\n                if (typeof type == 'undefined' || type == 'video') {\n                    getTracks(stream, 'video').forEach(function(track) {\n                        track.enabled = false;\n                    });\n                }\n\n                if (typeof syncAction == 'undefined' || syncAction == true) {\n                    StreamsHandler.onSyncNeeded(stream.streamid, 'mute', type);\n                }\n\n                connection.streamEvents[stream.streamid].muteType = type || 'both';\n\n                fireEvent(stream, 'mute', type);\n            };\n\n            stream.unmute = function(type, isSyncAction) {\n                type = handleType(type);\n\n                if (typeof isSyncAction !== 'undefined') {\n                    syncAction = isSyncAction;\n                }\n\n                graduallyIncreaseVolume();\n\n                if (typeof type == 'undefined' || type == 'audio') {\n                    getTracks(stream, 'audio').forEach(function(track) {\n                        track.enabled = true;\n                        connection.streamEvents[stream.streamid].isAudioMuted = false;\n                    });\n                }\n\n                if (typeof type == 'undefined' || type == 'video') {\n                    getTracks(stream, 'video').forEach(function(track) {\n                        track.enabled = true;\n                    });\n\n                    // make sure that video unmute doesn't affects audio\n                    if (typeof type !== 'undefined' && type == 'video' && connection.streamEvents[stream.streamid].isAudioMuted) {\n                        (function looper(times) {\n                            if (!times) {\n                                times = 0;\n                            }\n\n                            times++;\n\n                            // check until five-seconds\n                            if (times < 100 && connection.streamEvents[stream.streamid].isAudioMuted) {\n                                stream.mute('audio');\n\n                                setTimeout(function() {\n                                    looper(times);\n                                }, 50);\n                            }\n                        })();\n                    }\n                }\n\n                if (typeof syncAction == 'undefined' || syncAction == true) {\n                    StreamsHandler.onSyncNeeded(stream.streamid, 'unmute', type);\n                }\n\n                connection.streamEvents[stream.streamid].unmuteType = type || 'both';\n\n                fireEvent(stream, 'unmute', type);\n            };\n\n            function graduallyIncreaseVolume() {\n                if (!connection.streamEvents[stream.streamid].mediaElement) {\n                    return;\n                }\n\n                var mediaElement = connection.streamEvents[stream.streamid].mediaElement;\n                mediaElement.volume = 0;\n                afterEach(200, 5, function() {\n                    try {\n                        mediaElement.volume += .20;\n                    } catch (e) {\n                        mediaElement.volume = 1;\n                    }\n                });\n            }\n        }\n\n        function afterEach(setTimeoutInteval, numberOfTimes, callback, startedTimes) {\n            startedTimes = (startedTimes || 0) + 1;\n            if (startedTimes >= numberOfTimes) return;\n\n            setTimeout(function() {\n                callback();\n                afterEach(setTimeoutInteval, numberOfTimes, callback, startedTimes);\n            }, setTimeoutInteval);\n        }\n\n        return {\n            setHandlers: setHandlers,\n            onSyncNeeded: function(streamid, action, type) {}\n        };\n    })();\n\n    // Last time updated on: June 08, 2018\n\n    // Latest file can be found here: https://cdn.webrtc-experiment.com/Screen-Capturing.js\n\n    // Muaz Khan     - www.MuazKhan.com\n    // MIT License   - www.WebRTC-Experiment.com/licence\n    // Documentation - https://github.com/muaz-khan/Chrome-Extensions/tree/master/Screen-Capturing.js\n    // Demo          - https://www.webrtc-experiment.com/Screen-Capturing/\n\n    // ___________________\n    // Screen-Capturing.js\n\n    // Source code: https://github.com/muaz-khan/Chrome-Extensions/tree/master/desktopCapture\n    // Google AppStore installation path: https://chrome.google.com/webstore/detail/screen-capturing/ajhifddimkapgcifgcodmmfdlknahffk\n\n    // This JavaScript file is aimed to explain steps needed to integrate above chrome extension\n    // in your own webpages\n\n    // Usage:\n    // getScreenConstraints(function(screen_constraints) {\n    //    navigator.mediaDevices.getUserMedia({ video: screen_constraints }).then(onSuccess).catch(onFailure );\n    // });\n\n    // First Step: Download the extension, modify \"manifest.json\" and publish to Google AppStore\n    //             https://github.com/muaz-khan/Chrome-Extensions/tree/master/desktopCapture#how-to-publish-yourself\n\n    // Second Step: Listen for postMessage handler\n    // postMessage is used to exchange \"sourceId\" between chrome extension and you webpage.\n    // though, there are tons other options as well, e.g. XHR-signaling, websockets, etc.\n    window.addEventListener('message', function(event) {\n        if (event.origin != window.location.origin) {\n            return;\n        }\n\n        onMessageCallback(event.data);\n    });\n\n    // and the function that handles received messages\n\n    function onMessageCallback(data) {\n        // \"cancel\" button is clicked\n        if (data == 'PermissionDeniedError') {\n            chromeMediaSource = 'PermissionDeniedError';\n            if (screenCallback) return screenCallback('PermissionDeniedError');\n            else throw new Error('PermissionDeniedError');\n        }\n\n        // extension notified his presence\n        if (data == 'rtcmulticonnection-extension-loaded') {\n            chromeMediaSource = 'desktop';\n        }\n\n        // extension shared temp sourceId\n        if (data.sourceId && screenCallback) {\n            screenCallback(sourceId = data.sourceId, data.canRequestAudioTrack === true);\n        }\n    }\n\n    // global variables\n    var chromeMediaSource = 'screen';\n    var sourceId;\n    var screenCallback;\n\n    // this method can be used to check if chrome extension is installed & enabled.\n    function isChromeExtensionAvailable(callback) {\n        if (!callback) return;\n\n        if (chromeMediaSource == 'desktop') return callback(true);\n\n        // ask extension if it is available\n        window.postMessage('are-you-there', '*');\n\n        setTimeout(function() {\n            if (chromeMediaSource == 'screen') {\n                callback(false);\n            } else callback(true);\n        }, 2000);\n    }\n\n    // this function can be used to get \"source-id\" from the extension\n    function getSourceId(callback) {\n        if (!callback) throw '\"callback\" parameter is mandatory.';\n        if (sourceId) return callback(sourceId);\n\n        screenCallback = callback;\n        window.postMessage('get-sourceId', '*');\n    }\n\n    // this function can be used to get \"source-id\" from the extension\n    function getCustomSourceId(arr, callback) {\n        if (!arr || !arr.forEach) throw '\"arr\" parameter is mandatory and it must be an array.';\n        if (!callback) throw '\"callback\" parameter is mandatory.';\n\n        if (sourceId) return callback(sourceId);\n\n        screenCallback = callback;\n        window.postMessage({\n            'get-custom-sourceId': arr\n        }, '*');\n    }\n\n    // this function can be used to get \"source-id\" from the extension\n    function getSourceIdWithAudio(callback) {\n        if (!callback) throw '\"callback\" parameter is mandatory.';\n        if (sourceId) return callback(sourceId);\n\n        screenCallback = callback;\n        window.postMessage('audio-plus-tab', '*');\n    }\n\n    var isFirefox = typeof window.InstallTrigger !== 'undefined';\n    var isOpera = !!window.opera || navigator.userAgent.indexOf(' OPR/') >= 0;\n    var isChrome = !!window.chrome && !isOpera;\n\n    function getChromeExtensionStatus(extensionid, callback) {\n        if (isFirefox) return callback('not-chrome');\n\n        if (arguments.length != 2) {\n            callback = extensionid;\n            extensionid = 'ajhifddimkapgcifgcodmmfdlknahffk'; // default extension-id\n        }\n\n        var image = document.createElement('img');\n        image.src = 'chrome-extension://' + extensionid + '/icon.png';\n        image.onload = function() {\n            chromeMediaSource = 'screen';\n            window.postMessage('are-you-there', '*');\n            setTimeout(function() {\n                if (chromeMediaSource == 'screen') {\n                    callback('installed-disabled');\n                } else callback('installed-enabled');\n            }, 2000);\n        };\n        image.onerror = function() {\n            callback('not-installed');\n        };\n    }\n\n    function getScreenConstraintsWithAudio(callback) {\n        getScreenConstraints(callback, true);\n    }\n\n    // this function explains how to use above methods/objects\n    function getScreenConstraints(callback, captureSourceIdWithAudio) {\n        var firefoxScreenConstraints = {\n            mozMediaSource: 'window',\n            mediaSource: 'window'\n        };\n\n        if (isFirefox) return callback(null, firefoxScreenConstraints);\n\n        // this statement defines getUserMedia constraints\n        // that will be used to capture content of screen\n        var screen_constraints = {\n            mandatory: {\n                chromeMediaSource: chromeMediaSource,\n                maxWidth: screen.width > 1920 ? screen.width : 1920,\n                maxHeight: screen.height > 1080 ? screen.height : 1080\n            },\n            optional: []\n        };\n\n        // this statement verifies chrome extension availability\n        // if installed and available then it will invoke extension API\n        // otherwise it will fallback to command-line based screen capturing API\n        if (chromeMediaSource == 'desktop' && !sourceId) {\n            if (captureSourceIdWithAudio) {\n                getSourceIdWithAudio(function(sourceId, canRequestAudioTrack) {\n                    screen_constraints.mandatory.chromeMediaSourceId = sourceId;\n\n                    if (canRequestAudioTrack) {\n                        screen_constraints.canRequestAudioTrack = true;\n                    }\n                    callback(sourceId == 'PermissionDeniedError' ? sourceId : null, screen_constraints);\n                });\n            } else {\n                getSourceId(function(sourceId) {\n                    screen_constraints.mandatory.chromeMediaSourceId = sourceId;\n                    callback(sourceId == 'PermissionDeniedError' ? sourceId : null, screen_constraints);\n                });\n            }\n            return;\n        }\n\n        // this statement sets gets 'sourceId\" and sets \"chromeMediaSourceId\" \n        if (chromeMediaSource == 'desktop') {\n            screen_constraints.mandatory.chromeMediaSourceId = sourceId;\n        }\n\n        // now invoking native getUserMedia API\n        callback(null, screen_constraints);\n    }\n\n    // TextReceiver.js & TextSender.js\n\n    function TextReceiver(connection) {\n        var content = {};\n\n        function receive(data, userid, extra) {\n            // uuid is used to uniquely identify sending instance\n            var uuid = data.uuid;\n            if (!content[uuid]) {\n                content[uuid] = [];\n            }\n\n            content[uuid].push(data.message);\n\n            if (data.last) {\n                var message = content[uuid].join('');\n                if (data.isobject) {\n                    message = JSON.parse(message);\n                }\n\n                // latency detection\n                var receivingTime = new Date().getTime();\n                var latency = receivingTime - data.sendingTime;\n\n                var e = {\n                    data: message,\n                    userid: userid,\n                    extra: extra,\n                    latency: latency\n                };\n\n                if (connection.autoTranslateText) {\n                    e.original = e.data;\n                    connection.Translator.TranslateText(e.data, function(translatedText) {\n                        e.data = translatedText;\n                        connection.onmessage(e);\n                    });\n                } else {\n                    connection.onmessage(e);\n                }\n\n                delete content[uuid];\n            }\n        }\n\n        return {\n            receive: receive\n        };\n    }\n\n    // TextSender.js\n    var TextSender = {\n        send: function(config) {\n            var connection = config.connection;\n\n            var channel = config.channel,\n                remoteUserId = config.remoteUserId,\n                initialText = config.text,\n                packetSize = connection.chunkSize || 1000,\n                textToTransfer = '',\n                isobject = false;\n\n            if (!isString(initialText)) {\n                isobject = true;\n                initialText = JSON.stringify(initialText);\n            }\n\n            // uuid is used to uniquely identify sending instance\n            var uuid = getRandomString();\n            var sendingTime = new Date().getTime();\n\n            sendText(initialText);\n\n            function sendText(textMessage, text) {\n                var data = {\n                    type: 'text',\n                    uuid: uuid,\n                    sendingTime: sendingTime\n                };\n\n                if (textMessage) {\n                    text = textMessage;\n                    data.packets = parseInt(text.length / packetSize);\n                }\n\n                if (text.length > packetSize) {\n                    data.message = text.slice(0, packetSize);\n                } else {\n                    data.message = text;\n                    data.last = true;\n                    data.isobject = isobject;\n                }\n\n                channel.send(data, remoteUserId);\n\n                textToTransfer = text.slice(data.message.length);\n\n                if (textToTransfer.length) {\n                    setTimeout(function() {\n                        sendText(null, textToTransfer);\n                    }, connection.chunkInterval || 100);\n                }\n            }\n        }\n    };\n\n    // FileProgressBarHandler.js\n\n    var FileProgressBarHandler = (function() {\n        function handle(connection) {\n            var progressHelper = {};\n\n            // www.RTCMultiConnection.org/docs/onFileStart/\n            connection.onFileStart = function(file) {\n                var div = document.createElement('div');\n                div.title = file.name;\n                div.innerHTML = '<label>0%</label> <progress></progress>';\n\n                if (file.remoteUserId) {\n                    div.innerHTML += ' (Sharing with:' + file.remoteUserId + ')';\n                }\n\n                if (!connection.filesContainer) {\n                    connection.filesContainer = document.body || document.documentElement;\n                }\n\n                connection.filesContainer.insertBefore(div, connection.filesContainer.firstChild);\n\n                if (!file.remoteUserId) {\n                    progressHelper[file.uuid] = {\n                        div: div,\n                        progress: div.querySelector('progress'),\n                        label: div.querySelector('label')\n                    };\n                    progressHelper[file.uuid].progress.max = file.maxChunks;\n                    return;\n                }\n\n                if (!progressHelper[file.uuid]) {\n                    progressHelper[file.uuid] = {};\n                }\n\n                progressHelper[file.uuid][file.remoteUserId] = {\n                    div: div,\n                    progress: div.querySelector('progress'),\n                    label: div.querySelector('label')\n                };\n                progressHelper[file.uuid][file.remoteUserId].progress.max = file.maxChunks;\n            };\n\n            // www.RTCMultiConnection.org/docs/onFileProgress/\n            connection.onFileProgress = function(chunk) {\n                var helper = progressHelper[chunk.uuid];\n                if (!helper) {\n                    return;\n                }\n                if (chunk.remoteUserId) {\n                    helper = progressHelper[chunk.uuid][chunk.remoteUserId];\n                    if (!helper) {\n                        return;\n                    }\n                }\n\n                helper.progress.value = chunk.currentPosition || chunk.maxChunks || helper.progress.max;\n                updateLabel(helper.progress, helper.label);\n            };\n\n            // www.RTCMultiConnection.org/docs/onFileEnd/\n            connection.onFileEnd = function(file) {\n                var helper = progressHelper[file.uuid];\n                if (!helper) {\n                    console.error('No such progress-helper element exist.', file);\n                    return;\n                }\n\n                if (file.remoteUserId) {\n                    helper = progressHelper[file.uuid][file.remoteUserId];\n                    if (!helper) {\n                        return;\n                    }\n                }\n\n                var div = helper.div;\n                if (file.type.indexOf('image') != -1) {\n                    div.innerHTML = '<a href=\"' + file.url + '\" download=\"' + file.name + '\">Download <strong style=\"color:red;\">' + file.name + '</strong> </a><br /><img src=\"' + file.url + '\" title=\"' + file.name + '\" style=\"max-width: 80%;\">';\n                } else {\n                    div.innerHTML = '<a href=\"' + file.url + '\" download=\"' + file.name + '\">Download <strong style=\"color:red;\">' + file.name + '</strong> </a><br /><iframe src=\"' + file.url + '\" title=\"' + file.name + '\" style=\"width: 80%;border: 0;height: inherit;margin-top:1em;\"></iframe>';\n                }\n            };\n\n            function updateLabel(progress, label) {\n                if (progress.position === -1) {\n                    return;\n                }\n\n                var position = +progress.position.toFixed(2).split('.')[1] || 100;\n                label.innerHTML = position + '%';\n            }\n        }\n\n        return {\n            handle: handle\n        };\n    })();\n\n    // TranslationHandler.js\n\n    var TranslationHandler = (function() {\n        function handle(connection) {\n            connection.autoTranslateText = false;\n            connection.language = 'en';\n            connection.googKey = 'AIzaSyCgB5hmFY74WYB-EoWkhr9cAGr6TiTHrEE';\n\n            // www.RTCMultiConnection.org/docs/Translator/\n            connection.Translator = {\n                TranslateText: function(text, callback) {\n                    // if(location.protocol === 'https:') return callback(text);\n\n                    var newScript = document.createElement('script');\n                    newScript.type = 'text/javascript';\n\n                    var sourceText = encodeURIComponent(text); // escape\n\n                    var randomNumber = 'method' + connection.token();\n                    window[randomNumber] = function(response) {\n                        if (response.data && response.data.translations[0] && callback) {\n                            callback(response.data.translations[0].translatedText);\n                            return;\n                        }\n\n                        if (response.error && response.error.message === 'Daily Limit Exceeded') {\n                            console.error('Text translation failed. Error message: \"Daily Limit Exceeded.\"');\n                            return;\n                        }\n\n                        if (response.error) {\n                            console.error(response.error.message);\n                            return;\n                        }\n\n                        console.error(response);\n                    };\n\n                    var source = 'https://www.googleapis.com/language/translate/v2?key=' + connection.googKey + '&target=' + (connection.language || 'en-US') + '&callback=window.' + randomNumber + '&q=' + sourceText;\n                    newScript.src = source;\n                    document.getElementsByTagName('head')[0].appendChild(newScript);\n                },\n                getListOfLanguages: function(callback) {\n                    var xhr = new XMLHttpRequest();\n                    xhr.onreadystatechange = function() {\n                        if (xhr.readyState == XMLHttpRequest.DONE) {\n                            var response = JSON.parse(xhr.responseText);\n\n                            if (response && response.data && response.data.languages) {\n                                callback(response.data.languages);\n                                return;\n                            }\n\n                            if (response.error && response.error.message === 'Daily Limit Exceeded') {\n                                console.error('Text translation failed. Error message: \"Daily Limit Exceeded.\"');\n                                return;\n                            }\n\n                            if (response.error) {\n                                console.error(response.error.message);\n                                return;\n                            }\n\n                            console.error(response);\n                        }\n                    }\n                    var url = 'https://www.googleapis.com/language/translate/v2/languages?key=' + connection.googKey + '&target=en';\n                    xhr.open('GET', url, true);\n                    xhr.send(null);\n                }\n            };\n        }\n\n        return {\n            handle: handle\n        };\n    })();\n\n    // _____________________\n    // RTCMultiConnection.js\n\n    (function(connection) {\n        forceOptions = forceOptions || {\n            useDefaultDevices: true\n        };\n\n        connection.channel = connection.sessionid = (roomid || location.href.replace(/\\/|:|#|\\?|\\$|\\^|%|\\.|`|~|!|\\+|@|\\[|\\||]|\\|*. /g, '').split('\\n').join('').split('\\r').join('')) + '';\n\n        var mPeer = new MultiPeers(connection);\n\n        var preventDuplicateOnStreamEvents = {};\n        mPeer.onGettingLocalMedia = function(stream, callback) {\n            callback = callback || function() {};\n\n            if (preventDuplicateOnStreamEvents[stream.streamid]) {\n                callback();\n                return;\n            }\n            preventDuplicateOnStreamEvents[stream.streamid] = true;\n\n            try {\n                stream.type = 'local';\n            } catch (e) {}\n\n            connection.setStreamEndHandler(stream);\n\n            getRMCMediaElement(stream, function(mediaElement) {\n                mediaElement.id = stream.streamid;\n                mediaElement.muted = true;\n                mediaElement.volume = 0;\n\n                if (connection.attachStreams.indexOf(stream) === -1) {\n                    connection.attachStreams.push(stream);\n                }\n\n                if (typeof StreamsHandler !== 'undefined') {\n                    StreamsHandler.setHandlers(stream, true, connection);\n                }\n\n                connection.streamEvents[stream.streamid] = {\n                    stream: stream,\n                    type: 'local',\n                    mediaElement: mediaElement,\n                    userid: connection.userid,\n                    extra: connection.extra,\n                    streamid: stream.streamid,\n                    isAudioMuted: true\n                };\n\n                try {\n                    setHarkEvents(connection, connection.streamEvents[stream.streamid]);\n                    setMuteHandlers(connection, connection.streamEvents[stream.streamid]);\n\n                    connection.onstream(connection.streamEvents[stream.streamid]);\n                } catch (e) {\n                    //\n                }\n\n                callback();\n            }, connection);\n        };\n\n        mPeer.onGettingRemoteMedia = function(stream, remoteUserId) {\n            try {\n                stream.type = 'remote';\n            } catch (e) {}\n\n            connection.setStreamEndHandler(stream, 'remote-stream');\n\n            getRMCMediaElement(stream, function(mediaElement) {\n                mediaElement.id = stream.streamid;\n\n                if (typeof StreamsHandler !== 'undefined') {\n                    StreamsHandler.setHandlers(stream, false, connection);\n                }\n\n                connection.streamEvents[stream.streamid] = {\n                    stream: stream,\n                    type: 'remote',\n                    userid: remoteUserId,\n                    extra: connection.peers[remoteUserId] ? connection.peers[remoteUserId].extra : {},\n                    mediaElement: mediaElement,\n                    streamid: stream.streamid\n                };\n\n                setMuteHandlers(connection, connection.streamEvents[stream.streamid]);\n\n                connection.onstream(connection.streamEvents[stream.streamid]);\n            }, connection);\n        };\n\n        mPeer.onRemovingRemoteMedia = function(stream, remoteUserId) {\n            var streamEvent = connection.streamEvents[stream.streamid];\n            if (!streamEvent) {\n                streamEvent = {\n                    stream: stream,\n                    type: 'remote',\n                    userid: remoteUserId,\n                    extra: connection.peers[remoteUserId] ? connection.peers[remoteUserId].extra : {},\n                    streamid: stream.streamid,\n                    mediaElement: connection.streamEvents[stream.streamid] ? connection.streamEvents[stream.streamid].mediaElement : null\n                };\n            }\n\n            if (connection.peersBackup[streamEvent.userid]) {\n                streamEvent.extra = connection.peersBackup[streamEvent.userid].extra;\n            }\n\n            connection.onstreamended(streamEvent);\n\n            delete connection.streamEvents[stream.streamid];\n        };\n\n        mPeer.onNegotiationNeeded = function(message, remoteUserId, callback) {\n            callback = callback || function() {};\n\n            remoteUserId = remoteUserId || message.remoteUserId;\n            message = message || '';\n\n            // usually a message looks like this\n            var messageToDeliver = {\n                remoteUserId: remoteUserId,\n                message: message,\n                sender: connection.userid\n            };\n\n            if (message.remoteUserId && message.message && message.sender) {\n                // if a code is manually passing required data\n                messageToDeliver = message;\n            }\n\n            connectSocket(function() {\n                connection.socket.emit(connection.socketMessageEvent, messageToDeliver, callback);\n            });\n        };\n\n        function onUserLeft(remoteUserId) {\n            connection.deletePeer(remoteUserId);\n        }\n\n        mPeer.onUserLeft = onUserLeft;\n        mPeer.disconnectWith = function(remoteUserId, callback) {\n            if (connection.socket) {\n                connection.socket.emit('disconnect-with', remoteUserId, callback || function() {});\n            }\n\n            connection.deletePeer(remoteUserId);\n        };\n\n        connection.socketOptions = {\n            // 'force new connection': true, // For SocketIO version < 1.0\n            // 'forceNew': true, // For SocketIO version >= 1.0\n            'transport': 'polling' // fixing transport:unknown issues\n        };\n\n        function connectSocket(connectCallback) {\n            connection.socketAutoReConnect = true;\n\n            if (connection.socket) { // todo: check here readySate/etc. to make sure socket is still opened\n                if (connectCallback) {\n                    connectCallback(connection.socket);\n                }\n                return;\n            }\n\n            if (typeof SocketConnection === 'undefined') {\n                if (typeof FirebaseConnection !== 'undefined') {\n                    window.SocketConnection = FirebaseConnection;\n                } else if (typeof PubNubConnection !== 'undefined') {\n                    window.SocketConnection = PubNubConnection;\n                } else {\n                    throw 'SocketConnection.js seems missed.';\n                }\n            }\n\n            new SocketConnection(connection, function(s) {\n                if (connectCallback) {\n                    connectCallback(connection.socket);\n                }\n            });\n        }\n\n        // 1st paramter is roomid\n        // 2rd paramter is a callback function\n        connection.openOrJoin = function(roomid, callback) {\n            callback = callback || function() {};\n\n            connection.checkPresence(roomid, function(isRoomExist, roomid) {\n                if (isRoomExist) {\n                    connection.sessionid = roomid;\n\n                    var localPeerSdpConstraints = false;\n                    var remotePeerSdpConstraints = false;\n                    var isOneWay = !!connection.session.oneway;\n                    var isDataOnly = isData(connection.session);\n\n                    remotePeerSdpConstraints = {\n                        OfferToReceiveAudio: connection.sdpConstraints.mandatory.OfferToReceiveAudio,\n                        OfferToReceiveVideo: connection.sdpConstraints.mandatory.OfferToReceiveVideo\n                    }\n\n                    localPeerSdpConstraints = {\n                        OfferToReceiveAudio: isOneWay ? !!connection.session.audio : connection.sdpConstraints.mandatory.OfferToReceiveAudio,\n                        OfferToReceiveVideo: isOneWay ? !!connection.session.video || !!connection.session.screen : connection.sdpConstraints.mandatory.OfferToReceiveVideo\n                    }\n\n                    var connectionDescription = {\n                        remoteUserId: connection.sessionid,\n                        message: {\n                            newParticipationRequest: true,\n                            isOneWay: isOneWay,\n                            isDataOnly: isDataOnly,\n                            localPeerSdpConstraints: localPeerSdpConstraints,\n                            remotePeerSdpConstraints: remotePeerSdpConstraints\n                        },\n                        sender: connection.userid\n                    };\n\n                    beforeJoin(connectionDescription.message, function() {\n                        joinRoom(connectionDescription, callback);\n                    });\n                    return;\n                }\n\n                connection.waitingForLocalMedia = true;\n                connection.isInitiator = true;\n\n                connection.sessionid = roomid || connection.sessionid;\n\n                if (isData(connection.session)) {\n                    openRoom(callback);\n                    return;\n                }\n\n                connection.captureUserMedia(function() {\n                    openRoom(callback);\n                });\n            });\n        };\n\n        // don't allow someone to join this person until he has the media\n        connection.waitingForLocalMedia = false;\n\n        connection.open = function(roomid, callback) {\n            callback = callback || function() {};\n\n            connection.waitingForLocalMedia = true;\n            connection.isInitiator = true;\n\n            connection.sessionid = roomid || connection.sessionid;\n\n            connectSocket(function() {\n                if (isData(connection.session)) {\n                    openRoom(callback);\n                    return;\n                }\n\n                connection.captureUserMedia(function() {\n                    openRoom(callback);\n                });\n            });\n        };\n\n        // this object keeps extra-data records for all connected users\n        // this object is never cleared so you can always access extra-data even if a user left\n        connection.peersBackup = {};\n\n        connection.deletePeer = function(remoteUserId) {\n            if (!remoteUserId || !connection.peers[remoteUserId]) {\n                return;\n            }\n\n            var eventObject = {\n                userid: remoteUserId,\n                extra: connection.peers[remoteUserId] ? connection.peers[remoteUserId].extra : {}\n            };\n\n            if (connection.peersBackup[eventObject.userid]) {\n                eventObject.extra = connection.peersBackup[eventObject.userid].extra;\n            }\n\n            connection.onleave(eventObject);\n\n            if (!!connection.peers[remoteUserId]) {\n                connection.peers[remoteUserId].streams.forEach(function(stream) {\n                    stream.stop();\n                });\n\n                var peer = connection.peers[remoteUserId].peer;\n                if (peer && peer.iceConnectionState !== 'closed') {\n                    try {\n                        peer.close();\n                    } catch (e) {}\n                }\n\n                if (connection.peers[remoteUserId]) {\n                    connection.peers[remoteUserId].peer = null;\n                    delete connection.peers[remoteUserId];\n                }\n            }\n        }\n\n        connection.rejoin = function(connectionDescription) {\n            if (connection.isInitiator || !connectionDescription || !Object.keys(connectionDescription).length) {\n                return;\n            }\n\n            var extra = {};\n\n            if (connection.peers[connectionDescription.remoteUserId]) {\n                extra = connection.peers[connectionDescription.remoteUserId].extra;\n                connection.deletePeer(connectionDescription.remoteUserId);\n            }\n\n            if (connectionDescription && connectionDescription.remoteUserId) {\n                connection.join(connectionDescription.remoteUserId);\n\n                connection.onReConnecting({\n                    userid: connectionDescription.remoteUserId,\n                    extra: extra\n                });\n            }\n        };\n\n        connection.join = function(remoteUserId, options) {\n            connection.sessionid = (remoteUserId ? remoteUserId.sessionid || remoteUserId.remoteUserId || remoteUserId : false) || connection.sessionid;\n            connection.sessionid += '';\n\n            var localPeerSdpConstraints = false;\n            var remotePeerSdpConstraints = false;\n            var isOneWay = false;\n            var isDataOnly = false;\n\n            if ((remoteUserId && remoteUserId.session) || !remoteUserId || typeof remoteUserId === 'string') {\n                var session = remoteUserId ? remoteUserId.session || connection.session : connection.session;\n\n                isOneWay = !!session.oneway;\n                isDataOnly = isData(session);\n\n                remotePeerSdpConstraints = {\n                    OfferToReceiveAudio: connection.sdpConstraints.mandatory.OfferToReceiveAudio,\n                    OfferToReceiveVideo: connection.sdpConstraints.mandatory.OfferToReceiveVideo\n                };\n\n                localPeerSdpConstraints = {\n                    OfferToReceiveAudio: isOneWay ? !!connection.session.audio : connection.sdpConstraints.mandatory.OfferToReceiveAudio,\n                    OfferToReceiveVideo: isOneWay ? !!connection.session.video || !!connection.session.screen : connection.sdpConstraints.mandatory.OfferToReceiveVideo\n                };\n            }\n\n            options = options || {};\n\n            var cb = function() {};\n            if (typeof options === 'function') {\n                cb = options;\n                options = {};\n            }\n\n            if (typeof options.localPeerSdpConstraints !== 'undefined') {\n                localPeerSdpConstraints = options.localPeerSdpConstraints;\n            }\n\n            if (typeof options.remotePeerSdpConstraints !== 'undefined') {\n                remotePeerSdpConstraints = options.remotePeerSdpConstraints;\n            }\n\n            if (typeof options.isOneWay !== 'undefined') {\n                isOneWay = options.isOneWay;\n            }\n\n            if (typeof options.isDataOnly !== 'undefined') {\n                isDataOnly = options.isDataOnly;\n            }\n\n            var connectionDescription = {\n                remoteUserId: connection.sessionid,\n                message: {\n                    newParticipationRequest: true,\n                    isOneWay: isOneWay,\n                    isDataOnly: isDataOnly,\n                    localPeerSdpConstraints: localPeerSdpConstraints,\n                    remotePeerSdpConstraints: remotePeerSdpConstraints\n                },\n                sender: connection.userid\n            };\n\n            beforeJoin(connectionDescription.message, function() {\n                connectSocket(function() {\n                    joinRoom(connectionDescription, cb);\n                });\n            });\n            return connectionDescription;\n        };\n\n        function joinRoom(connectionDescription, cb) {\n            connection.socket.emit('join-room', {\n                sessionid: connection.sessionid,\n                session: connection.session,\n                mediaConstraints: connection.mediaConstraints,\n                sdpConstraints: connection.sdpConstraints,\n                streams: getStreamInfoForAdmin(),\n                extra: connection.extra,\n                password: typeof connection.password !== 'undefined' && typeof connection.password !== 'object' ? connection.password : ''\n            }, function(isRoomJoined, error) {\n                if (isRoomJoined === true) {\n                    if (connection.enableLogs) {\n                        console.log('isRoomJoined: ', isRoomJoined, ' roomid: ', connection.sessionid);\n                    }\n\n                    if (!!connection.peers[connection.sessionid]) {\n                        // on socket disconnect & reconnect\n                        return;\n                    }\n\n                    mPeer.onNegotiationNeeded(connectionDescription);\n                }\n\n                if (isRoomJoined === false) {\n                    if (connection.enableLogs) {\n                        console.warn('isRoomJoined: ', error, ' roomid: ', connection.sessionid);\n                    }\n\n                    // [disabled] retry after 3 seconds\n                     false && false;\n                }\n\n                cb(isRoomJoined, connection.sessionid, error);\n            });\n        }\n\n        connection.publicRoomIdentifier = '';\n\n        function openRoom(callback) {\n            if (connection.enableLogs) {\n                console.log('Sending open-room signal to socket.io');\n            }\n\n            connection.waitingForLocalMedia = false;\n            connection.socket.emit('open-room', {\n                sessionid: connection.sessionid,\n                session: connection.session,\n                mediaConstraints: connection.mediaConstraints,\n                sdpConstraints: connection.sdpConstraints,\n                streams: getStreamInfoForAdmin(),\n                extra: connection.extra,\n                identifier: connection.publicRoomIdentifier,\n                password: typeof connection.password !== 'undefined' && typeof connection.password !== 'object' ? connection.password : ''\n            }, function(isRoomOpened, error) {\n                if (isRoomOpened === true) {\n                    if (connection.enableLogs) {\n                        console.log('isRoomOpened: ', isRoomOpened, ' roomid: ', connection.sessionid);\n                    }\n                    callback(isRoomOpened, connection.sessionid);\n                }\n\n                if (isRoomOpened === false) {\n                    if (connection.enableLogs) {\n                        console.warn('isRoomOpened: ', error, ' roomid: ', connection.sessionid);\n                    }\n\n                    callback(isRoomOpened, connection.sessionid, error);\n                }\n            });\n        }\n\n        function getStreamInfoForAdmin() {\n            try {\n                return connection.streamEvents.selectAll('local').map(function(event) {\n                    return {\n                        streamid: event.streamid,\n                        tracks: event.stream.getTracks().length\n                    };\n                });\n            } catch (e) {\n                return [];\n            }\n        }\n\n        function beforeJoin(userPreferences, callback) {\n            if (connection.dontCaptureUserMedia || userPreferences.isDataOnly) {\n                callback();\n                return;\n            }\n\n            var localMediaConstraints = {};\n\n            if (userPreferences.localPeerSdpConstraints.OfferToReceiveAudio) {\n                localMediaConstraints.audio = connection.mediaConstraints.audio;\n            }\n\n            if (userPreferences.localPeerSdpConstraints.OfferToReceiveVideo) {\n                localMediaConstraints.video = connection.mediaConstraints.video;\n            }\n\n            var session = userPreferences.session || connection.session;\n\n            if (session.oneway && session.audio !== 'two-way' && session.video !== 'two-way' && session.screen !== 'two-way') {\n                callback();\n                return;\n            }\n\n            if (session.oneway && session.audio && session.audio === 'two-way') {\n                session = {\n                    audio: true\n                };\n            }\n\n            if (session.audio || session.video || session.screen) {\n                if (session.screen) {\n                    if (DetectRTC.browser.name === 'Edge') {\n                        navigator.getDisplayMedia({\n                            video: true,\n                            audio: isAudioPlusTab(connection)\n                        }).then(function(screen) {\n                            screen.isScreen = true;\n                            mPeer.onGettingLocalMedia(screen);\n\n                            if ((session.audio || session.video) && !isAudioPlusTab(connection)) {\n                                connection.invokeGetUserMedia(null, callback);\n                            } else {\n                                callback(screen);\n                            }\n                        }, function(error) {\n                            console.error('Unable to capture screen on Edge. HTTPs and version 17+ is required.');\n                        });\n                    } else {\n                        connection.getScreenConstraints(function(error, screen_constraints) {\n                            connection.invokeGetUserMedia({\n                                audio: isAudioPlusTab(connection) ? getAudioScreenConstraints(screen_constraints) : false,\n                                video: screen_constraints,\n                                isScreen: true\n                            }, (session.audio || session.video) && !isAudioPlusTab(connection) ? connection.invokeGetUserMedia(null, callback) : callback);\n                        });\n                    }\n                } else if (session.audio || session.video) {\n                    connection.invokeGetUserMedia(null, callback, session);\n                }\n            }\n        }\n\n        connection.getUserMedia = connection.captureUserMedia = function(callback, sessionForced) {\n            callback = callback || function() {};\n            var session = sessionForced || connection.session;\n\n            if (connection.dontCaptureUserMedia || isData(session)) {\n                callback();\n                return;\n            }\n\n            if (session.audio || session.video || session.screen) {\n                if (session.screen) {\n                    if (DetectRTC.browser.name === 'Edge') {\n                        navigator.getDisplayMedia({\n                            video: true,\n                            audio: isAudioPlusTab(connection)\n                        }).then(function(screen) {\n                            screen.isScreen = true;\n                            mPeer.onGettingLocalMedia(screen);\n\n                            if ((session.audio || session.video) && !isAudioPlusTab(connection)) {\n                                var nonScreenSession = {};\n                                for (var s in session) {\n                                    if (s !== 'screen') {\n                                        nonScreenSession[s] = session[s];\n                                    }\n                                }\n                                connection.invokeGetUserMedia(sessionForced, callback, nonScreenSession);\n                                return;\n                            }\n                            callback(screen);\n                        }, function(error) {\n                            console.error('Unable to capture screen on Edge. HTTPs and version 17+ is required.');\n                        });\n                    } else {\n                        connection.getScreenConstraints(function(error, screen_constraints) {\n                            if (error) {\n                                throw error;\n                            }\n\n                            connection.invokeGetUserMedia({\n                                audio: isAudioPlusTab(connection) ? getAudioScreenConstraints(screen_constraints) : false,\n                                video: screen_constraints,\n                                isScreen: true\n                            }, function(stream) {\n                                if ((session.audio || session.video) && !isAudioPlusTab(connection)) {\n                                    var nonScreenSession = {};\n                                    for (var s in session) {\n                                        if (s !== 'screen') {\n                                            nonScreenSession[s] = session[s];\n                                        }\n                                    }\n                                    connection.invokeGetUserMedia(sessionForced, callback, nonScreenSession);\n                                    return;\n                                }\n                                callback(stream);\n                            });\n                        });\n                    }\n                } else if (session.audio || session.video) {\n                    connection.invokeGetUserMedia(sessionForced, callback, session);\n                }\n            }\n        };\n\n        connection.onbeforeunload = function(arg1, dontCloseSocket) {\n            if (!connection.closeBeforeUnload) {\n                return;\n            }\n\n            connection.peers.getAllParticipants().forEach(function(participant) {\n                mPeer.onNegotiationNeeded({\n                    userLeft: true\n                }, participant);\n\n                if (connection.peers[participant] && connection.peers[participant].peer) {\n                    connection.peers[participant].peer.close();\n                }\n\n                delete connection.peers[participant];\n            });\n\n            if (!dontCloseSocket) {\n                connection.closeSocket();\n            }\n\n            connection.isInitiator = false;\n        };\n\n        if (!window.ignoreBeforeUnload) {\n            // user can implement its own version of window.onbeforeunload\n            connection.closeBeforeUnload = true;\n            window.addEventListener('beforeunload', connection.onbeforeunload, false);\n        } else {\n            connection.closeBeforeUnload = false;\n        }\n\n        connection.userid = getRandomString();\n        connection.changeUserId = function(newUserId, callback) {\n            callback = callback || function() {};\n            connection.userid = newUserId || getRandomString();\n            connection.socket.emit('changed-uuid', connection.userid, callback);\n        };\n\n        connection.extra = {};\n        connection.attachStreams = [];\n\n        connection.session = {\n            audio: true,\n            video: true\n        };\n\n        connection.enableFileSharing = false;\n\n        // all values in kbps\n        connection.bandwidth = {\n            screen: false,\n            audio: false,\n            video: false\n        };\n\n        connection.codecs = {\n            audio: 'opus',\n            video: 'VP9'\n        };\n\n        connection.processSdp = function(sdp) {\n            // ignore SDP modification if unified-pan is supported\n            if (isUnifiedPlanSupportedDefault()) {\n                return sdp;\n            }\n\n            if (DetectRTC.browser.name === 'Safari') {\n                return sdp;\n            }\n\n            if (connection.codecs.video.toUpperCase() === 'VP8') {\n                sdp = CodecsHandler.preferCodec(sdp, 'vp8');\n            }\n\n            if (connection.codecs.video.toUpperCase() === 'VP9') {\n                sdp = CodecsHandler.preferCodec(sdp, 'vp9');\n            }\n\n            if (connection.codecs.video.toUpperCase() === 'H264') {\n                sdp = CodecsHandler.preferCodec(sdp, 'h264');\n            }\n\n            if (connection.codecs.audio === 'G722') {\n                sdp = CodecsHandler.removeNonG722(sdp);\n            }\n\n            if (DetectRTC.browser.name === 'Firefox') {\n                return sdp;\n            }\n\n            if (connection.bandwidth.video || connection.bandwidth.screen) {\n                sdp = CodecsHandler.setApplicationSpecificBandwidth(sdp, connection.bandwidth, !!connection.session.screen);\n            }\n\n            if (connection.bandwidth.video) {\n                sdp = CodecsHandler.setVideoBitrates(sdp, {\n                    min: connection.bandwidth.video * 8 * 1024,\n                    max: connection.bandwidth.video * 8 * 1024\n                });\n            }\n\n            if (connection.bandwidth.audio) {\n                sdp = CodecsHandler.setOpusAttributes(sdp, {\n                    maxaveragebitrate: connection.bandwidth.audio * 8 * 1024,\n                    maxplaybackrate: connection.bandwidth.audio * 8 * 1024,\n                    stereo: 1,\n                    maxptime: 3\n                });\n            }\n\n            return sdp;\n        };\n\n        if (typeof CodecsHandler !== 'undefined') {\n            connection.BandwidthHandler = connection.CodecsHandler = CodecsHandler;\n        }\n\n        connection.mediaConstraints = {\n            audio: {\n                mandatory: {},\n                optional: connection.bandwidth.audio ? [{\n                    bandwidth: connection.bandwidth.audio * 8 * 1024 || 128 * 8 * 1024\n                }] : []\n            },\n            video: {\n                mandatory: {},\n                optional: connection.bandwidth.video ? [{\n                    bandwidth: connection.bandwidth.video * 8 * 1024 || 128 * 8 * 1024\n                }, {\n                    facingMode: 'user'\n                }] : [{\n                    facingMode: 'user'\n                }]\n            }\n        };\n\n        if (DetectRTC.browser.name === 'Firefox') {\n            connection.mediaConstraints = {\n                audio: true,\n                video: true\n            };\n        }\n\n        if (!forceOptions.useDefaultDevices && !DetectRTC.isMobileDevice) {\n            DetectRTC.load(function() {\n                var lastAudioDevice, lastVideoDevice;\n                // it will force RTCMultiConnection to capture last-devices\n                // i.e. if external microphone is attached to system, we should prefer it over built-in devices.\n                DetectRTC.MediaDevices.forEach(function(device) {\n                    if (device.kind === 'audioinput' && connection.mediaConstraints.audio !== false) {\n                        lastAudioDevice = device;\n                    }\n\n                    if (device.kind === 'videoinput' && connection.mediaConstraints.video !== false) {\n                        lastVideoDevice = device;\n                    }\n                });\n\n                if (lastAudioDevice) {\n                    if (DetectRTC.browser.name === 'Firefox') {\n                        if (connection.mediaConstraints.audio !== true) {\n                            connection.mediaConstraints.audio.deviceId = lastAudioDevice.id;\n                        } else {\n                            connection.mediaConstraints.audio = {\n                                deviceId: lastAudioDevice.id\n                            }\n                        }\n                        return;\n                    }\n\n                    if (connection.mediaConstraints.audio == true) {\n                        connection.mediaConstraints.audio = {\n                            mandatory: {},\n                            optional: []\n                        }\n                    }\n\n                    if (!connection.mediaConstraints.audio.optional) {\n                        connection.mediaConstraints.audio.optional = [];\n                    }\n\n                    var optional = [{\n                        sourceId: lastAudioDevice.id\n                    }];\n\n                    connection.mediaConstraints.audio.optional = optional.concat(connection.mediaConstraints.audio.optional);\n                }\n\n                if (lastVideoDevice) {\n                    if (DetectRTC.browser.name === 'Firefox') {\n                        if (connection.mediaConstraints.video !== true) {\n                            connection.mediaConstraints.video.deviceId = lastVideoDevice.id;\n                        } else {\n                            connection.mediaConstraints.video = {\n                                deviceId: lastVideoDevice.id\n                            }\n                        }\n                        return;\n                    }\n\n                    if (connection.mediaConstraints.video == true) {\n                        connection.mediaConstraints.video = {\n                            mandatory: {},\n                            optional: []\n                        }\n                    }\n\n                    if (!connection.mediaConstraints.video.optional) {\n                        connection.mediaConstraints.video.optional = [];\n                    }\n\n                    var optional = [{\n                        sourceId: lastVideoDevice.id\n                    }];\n\n                    connection.mediaConstraints.video.optional = optional.concat(connection.mediaConstraints.video.optional);\n                }\n            });\n        }\n\n        connection.sdpConstraints = {\n            mandatory: {\n                OfferToReceiveAudio: true,\n                OfferToReceiveVideo: true\n            },\n            optional: [{\n                VoiceActivityDetection: false\n            }]\n        };\n\n        connection.sdpSemantics = null; // \"unified-plan\" or \"plan-b\", ref: webrtc.org/web-apis/chrome/unified-plan/\n        connection.iceCandidatePoolSize = null; // 0\n        connection.bundlePolicy = null; // max-bundle\n        connection.rtcpMuxPolicy = null; // \"require\" or \"negotiate\"\n        connection.iceTransportPolicy = null; // \"relay\" or \"all\"\n        connection.optionalArgument = {\n            optional: [{\n                DtlsSrtpKeyAgreement: true\n            }, {\n                googImprovedWifiBwe: true\n            }, {\n                googScreencastMinBitrate: 300\n            }, {\n                googIPv6: true\n            }, {\n                googDscp: true\n            }, {\n                googCpuUnderuseThreshold: 55\n            }, {\n                googCpuOveruseThreshold: 85\n            }, {\n                googSuspendBelowMinBitrate: true\n            }, {\n                googCpuOveruseDetection: true\n            }],\n            mandatory: {}\n        };\n\n        connection.iceServers = IceServersHandler.getIceServers(connection);\n\n        connection.candidates = {\n            host: true,\n            stun: true,\n            turn: true\n        };\n\n        connection.iceProtocols = {\n            tcp: true,\n            udp: true\n        };\n\n        // EVENTs\n        connection.onopen = function(event) {\n            if (!!connection.enableLogs) {\n                console.info('Data connection has been opened between you & ', event.userid);\n            }\n        };\n\n        connection.onclose = function(event) {\n            if (!!connection.enableLogs) {\n                console.warn('Data connection has been closed between you & ', event.userid);\n            }\n        };\n\n        connection.onerror = function(error) {\n            if (!!connection.enableLogs) {\n                console.error(error.userid, 'data-error', error);\n            }\n        };\n\n        connection.onmessage = function(event) {\n            if (!!connection.enableLogs) {\n                console.debug('data-message', event.userid, event.data);\n            }\n        };\n\n        connection.send = function(data, remoteUserId) {\n            connection.peers.send(data, remoteUserId);\n        };\n\n        connection.close = connection.disconnect = connection.leave = function() {\n            connection.onbeforeunload(false, true);\n        };\n\n        connection.closeEntireSession = function(callback) {\n            callback = callback || function() {};\n            connection.socket.emit('close-entire-session', function looper() {\n                if (connection.getAllParticipants().length) {\n                    setTimeout(looper, 100);\n                    return;\n                }\n\n                connection.onEntireSessionClosed({\n                    sessionid: connection.sessionid,\n                    userid: connection.userid,\n                    extra: connection.extra\n                });\n\n                connection.changeUserId(null, function() {\n                    connection.close();\n                    callback();\n                });\n            });\n        };\n\n        connection.onEntireSessionClosed = function(event) {\n            if (!connection.enableLogs) return;\n            console.info('Entire session is closed: ', event.sessionid, event.extra);\n        };\n\n        connection.onstream = function(e) {\n            var parentNode = connection.videosContainer;\n            parentNode.insertBefore(e.mediaElement, parentNode.firstChild);\n            var played = e.mediaElement.play();\n\n            if (typeof played !== 'undefined') {\n                played.catch(function() {\n                    /*** iOS 11 doesn't allow automatic play and rejects ***/\n                }).then(function() {\n                    setTimeout(function() {\n                        e.mediaElement.play();\n                    }, 2000);\n                });\n                return;\n            }\n\n            setTimeout(function() {\n                e.mediaElement.play();\n            }, 2000);\n        };\n\n        connection.onstreamended = function(e) {\n            if (!e.mediaElement) {\n                e.mediaElement = document.getElementById(e.streamid);\n            }\n\n            if (!e.mediaElement || !e.mediaElement.parentNode) {\n                return;\n            }\n\n            e.mediaElement.parentNode.removeChild(e.mediaElement);\n        };\n\n        connection.direction = 'many-to-many';\n\n        connection.removeStream = function(streamid, remoteUserId) {\n            var stream;\n            connection.attachStreams.forEach(function(localStream) {\n                if (localStream.id === streamid) {\n                    stream = localStream;\n                }\n            });\n\n            if (!stream) {\n                console.warn('No such stream exist.', streamid);\n                return;\n            }\n\n            connection.peers.getAllParticipants().forEach(function(participant) {\n                if (remoteUserId && participant !== remoteUserId) {\n                    return;\n                }\n\n                var user = connection.peers[participant];\n                try {\n                    user.peer.removeStream(stream);\n                } catch (e) {}\n            });\n\n            connection.renegotiate();\n        };\n\n        connection.addStream = function(session, remoteUserId) {\n            if (!!session.getTracks) {\n                if (connection.attachStreams.indexOf(session) === -1) {\n                    if (!session.streamid) {\n                        session.streamid = session.id;\n                    }\n\n                    connection.attachStreams.push(session);\n                }\n                connection.renegotiate(remoteUserId);\n                return;\n            }\n\n            if (isData(session)) {\n                connection.renegotiate(remoteUserId);\n                return;\n            }\n\n            if (session.audio || session.video || session.screen) {\n                if (session.screen) {\n                    if (DetectRTC.browser.name === 'Edge') {\n                        navigator.getDisplayMedia({\n                            video: true,\n                            audio: isAudioPlusTab(connection)\n                        }).then(function(screen) {\n                            screen.isScreen = true;\n                            mPeer.onGettingLocalMedia(screen);\n\n                            if ((session.audio || session.video) && !isAudioPlusTab(connection)) {\n                                connection.invokeGetUserMedia(null, function(stream) {\n                                    gumCallback(stream);\n                                });\n                            } else {\n                                gumCallback(screen);\n                            }\n                        }, function(error) {\n                            console.error('Unable to capture screen on Edge. HTTPs and version 17+ is required.');\n                        });\n                    } else {\n                        connection.getScreenConstraints(function(error, screen_constraints) {\n                            if (error) {\n                                if (error === 'PermissionDeniedError') {\n                                    if (session.streamCallback) {\n                                        session.streamCallback(null);\n                                    }\n                                    if (connection.enableLogs) {\n                                        console.error('User rejected to share his screen.');\n                                    }\n                                    return;\n                                }\n                                return alert(error);\n                            }\n\n                            connection.invokeGetUserMedia({\n                                audio: isAudioPlusTab(connection) ? getAudioScreenConstraints(screen_constraints) : false,\n                                video: screen_constraints,\n                                isScreen: true\n                            }, function(stream) {\n                                if ((session.audio || session.video) && !isAudioPlusTab(connection)) {\n                                    connection.invokeGetUserMedia(null, function(stream) {\n                                        gumCallback(stream);\n                                    });\n                                } else {\n                                    gumCallback(stream);\n                                }\n                            });\n                        });\n                    }\n                } else if (session.audio || session.video) {\n                    connection.invokeGetUserMedia(null, gumCallback);\n                }\n            }\n\n            function gumCallback(stream) {\n                if (session.streamCallback) {\n                    session.streamCallback(stream);\n                }\n\n                connection.renegotiate(remoteUserId);\n            }\n        };\n\n        connection.invokeGetUserMedia = function(localMediaConstraints, callback, session) {\n            if (!session) {\n                session = connection.session;\n            }\n\n            if (!localMediaConstraints) {\n                localMediaConstraints = connection.mediaConstraints;\n            }\n\n            getUserMediaHandler({\n                onGettingLocalMedia: function(stream) {\n                    var videoConstraints = localMediaConstraints.video;\n                    if (videoConstraints) {\n                        if (videoConstraints.mediaSource || videoConstraints.mozMediaSource) {\n                            stream.isScreen = true;\n                        } else if (videoConstraints.mandatory && videoConstraints.mandatory.chromeMediaSource) {\n                            stream.isScreen = true;\n                        }\n                    }\n\n                    if (!stream.isScreen) {\n                        stream.isVideo = !!getTracks(stream, 'video').length;\n                        stream.isAudio = !stream.isVideo && getTracks(stream, 'audio').length;\n                    }\n\n                    mPeer.onGettingLocalMedia(stream, function() {\n                        if (typeof callback === 'function') {\n                            callback(stream);\n                        }\n                    });\n                },\n                onLocalMediaError: function(error, constraints) {\n                    mPeer.onLocalMediaError(error, constraints);\n                },\n                localMediaConstraints: localMediaConstraints || {\n                    audio: session.audio ? localMediaConstraints.audio : false,\n                    video: session.video ? localMediaConstraints.video : false\n                }\n            });\n        };\n\n        function applyConstraints(stream, mediaConstraints) {\n            if (!stream) {\n                if (!!connection.enableLogs) {\n                    console.error('No stream to applyConstraints.');\n                }\n                return;\n            }\n\n            if (mediaConstraints.audio) {\n                getTracks(stream, 'audio').forEach(function(track) {\n                    track.applyConstraints(mediaConstraints.audio);\n                });\n            }\n\n            if (mediaConstraints.video) {\n                getTracks(stream, 'video').forEach(function(track) {\n                    track.applyConstraints(mediaConstraints.video);\n                });\n            }\n        }\n\n        connection.applyConstraints = function(mediaConstraints, streamid) {\n            if (!MediaStreamTrack || !MediaStreamTrack.prototype.applyConstraints) {\n                alert('track.applyConstraints is NOT supported in your browser.');\n                return;\n            }\n\n            if (streamid) {\n                var stream;\n                if (connection.streamEvents[streamid]) {\n                    stream = connection.streamEvents[streamid].stream;\n                }\n                applyConstraints(stream, mediaConstraints);\n                return;\n            }\n\n            connection.attachStreams.forEach(function(stream) {\n                applyConstraints(stream, mediaConstraints);\n            });\n        };\n\n        function replaceTrack(track, remoteUserId, isVideoTrack) {\n            if (remoteUserId) {\n                mPeer.replaceTrack(track, remoteUserId, isVideoTrack);\n                return;\n            }\n\n            connection.peers.getAllParticipants().forEach(function(participant) {\n                mPeer.replaceTrack(track, participant, isVideoTrack);\n            });\n        }\n\n        connection.replaceTrack = function(session, remoteUserId, isVideoTrack) {\n            session = session || {};\n\n            if (!RTCPeerConnection.prototype.getSenders) {\n                connection.addStream(session);\n                return;\n            }\n\n            if (session instanceof MediaStreamTrack) {\n                replaceTrack(session, remoteUserId, isVideoTrack);\n                return;\n            }\n\n            if (session instanceof MediaStream) {\n                if (getTracks(session, 'video').length) {\n                    replaceTrack(getTracks(session, 'video')[0], remoteUserId, true);\n                }\n\n                if (getTracks(session, 'audio').length) {\n                    replaceTrack(getTracks(session, 'audio')[0], remoteUserId, false);\n                }\n                return;\n            }\n\n            if (isData(session)) {\n                throw 'connection.replaceTrack requires audio and/or video and/or screen.';\n                return;\n            }\n\n            if (session.audio || session.video || session.screen) {\n                if (session.screen) {\n                    if (DetectRTC.browser.name === 'Edge') {\n                        navigator.getDisplayMedia({\n                            video: true,\n                            audio: isAudioPlusTab(connection)\n                        }).then(function(screen) {\n                            screen.isScreen = true;\n                            mPeer.onGettingLocalMedia(screen);\n\n                            if ((session.audio || session.video) && !isAudioPlusTab(connection)) {\n                                connection.invokeGetUserMedia(null, gumCallback);\n                            } else {\n                                gumCallback(screen);\n                            }\n                        }, function(error) {\n                            console.error('Unable to capture screen on Edge. HTTPs and version 17+ is required.');\n                        });\n                    } else {\n                        connection.getScreenConstraints(function(error, screen_constraints) {\n                            if (error) {\n                                return alert(error);\n                            }\n\n                            connection.invokeGetUserMedia({\n                                audio: isAudioPlusTab(connection) ? getAudioScreenConstraints(screen_constraints) : false,\n                                video: screen_constraints,\n                                isScreen: true\n                            }, (session.audio || session.video) && !isAudioPlusTab(connection) ? connection.invokeGetUserMedia(null, gumCallback) : gumCallback);\n                        });\n                    }\n                } else if (session.audio || session.video) {\n                    connection.invokeGetUserMedia(null, gumCallback);\n                }\n            }\n\n            function gumCallback(stream) {\n                connection.replaceTrack(stream, remoteUserId, isVideoTrack || session.video || session.screen);\n            }\n        };\n\n        connection.resetTrack = function(remoteUsersIds, isVideoTrack) {\n            if (!remoteUsersIds) {\n                remoteUsersIds = connection.getAllParticipants();\n            }\n\n            if (typeof remoteUsersIds == 'string') {\n                remoteUsersIds = [remoteUsersIds];\n            }\n\n            remoteUsersIds.forEach(function(participant) {\n                var peer = connection.peers[participant].peer;\n\n                if ((typeof isVideoTrack === 'undefined' || isVideoTrack === true) && peer.lastVideoTrack) {\n                    connection.replaceTrack(peer.lastVideoTrack, participant, true);\n                }\n\n                if ((typeof isVideoTrack === 'undefined' || isVideoTrack === false) && peer.lastAudioTrack) {\n                    connection.replaceTrack(peer.lastAudioTrack, participant, false);\n                }\n            });\n        };\n\n        connection.renegotiate = function(remoteUserId) {\n            if (remoteUserId) {\n                mPeer.renegotiatePeer(remoteUserId);\n                return;\n            }\n\n            connection.peers.getAllParticipants().forEach(function(participant) {\n                mPeer.renegotiatePeer(participant);\n            });\n        };\n\n        connection.setStreamEndHandler = function(stream, isRemote) {\n            if (!stream || !stream.addEventListener) return;\n\n            isRemote = !!isRemote;\n\n            if (stream.alreadySetEndHandler) {\n                return;\n            }\n            stream.alreadySetEndHandler = true;\n\n            var streamEndedEvent = 'ended';\n\n            if ('oninactive' in stream) {\n                streamEndedEvent = 'inactive';\n            }\n\n            stream.addEventListener(streamEndedEvent, function() {\n                if (stream.idInstance) {\n                    currentUserMediaRequest.remove(stream.idInstance);\n                }\n\n                if (!isRemote) {\n                    // reset attachStreams\n                    var streams = [];\n                    connection.attachStreams.forEach(function(s) {\n                        if (s.id != stream.id) {\n                            streams.push(s);\n                        }\n                    });\n                    connection.attachStreams = streams;\n                }\n\n                // connection.renegotiate();\n\n                var streamEvent = connection.streamEvents[stream.streamid];\n                if (!streamEvent) {\n                    streamEvent = {\n                        stream: stream,\n                        streamid: stream.streamid,\n                        type: isRemote ? 'remote' : 'local',\n                        userid: connection.userid,\n                        extra: connection.extra,\n                        mediaElement: connection.streamEvents[stream.streamid] ? connection.streamEvents[stream.streamid].mediaElement : null\n                    };\n                }\n\n                if (isRemote && connection.peers[streamEvent.userid]) {\n                    // reset remote \"streams\"\n                    var peer = connection.peers[streamEvent.userid].peer;\n                    var streams = [];\n                    peer.getRemoteStreams().forEach(function(s) {\n                        if (s.id != stream.id) {\n                            streams.push(s);\n                        }\n                    });\n                    connection.peers[streamEvent.userid].streams = streams;\n                }\n\n                if (streamEvent.userid === connection.userid && streamEvent.type === 'remote') {\n                    return;\n                }\n\n                if (connection.peersBackup[streamEvent.userid]) {\n                    streamEvent.extra = connection.peersBackup[streamEvent.userid].extra;\n                }\n\n                connection.onstreamended(streamEvent);\n\n                delete connection.streamEvents[stream.streamid];\n            }, false);\n        };\n\n        connection.onMediaError = function(error, constraints) {\n            if (!!connection.enableLogs) {\n                console.error(error, constraints);\n            }\n        };\n\n        connection.autoCloseEntireSession = false;\n\n        connection.filesContainer = connection.videosContainer = document.body || document.documentElement;\n        connection.isInitiator = false;\n\n        connection.shareFile = mPeer.shareFile;\n        if (typeof FileProgressBarHandler !== 'undefined') {\n            FileProgressBarHandler.handle(connection);\n        }\n\n        if (typeof TranslationHandler !== 'undefined') {\n            TranslationHandler.handle(connection);\n        }\n\n        connection.token = getRandomString;\n\n        connection.onNewParticipant = function(participantId, userPreferences) {\n            connection.acceptParticipationRequest(participantId, userPreferences);\n        };\n\n        connection.acceptParticipationRequest = function(participantId, userPreferences) {\n            if (userPreferences.successCallback) {\n                userPreferences.successCallback();\n                delete userPreferences.successCallback;\n            }\n\n            mPeer.createNewPeer(participantId, userPreferences);\n        };\n\n        if (typeof StreamsHandler !== 'undefined') {\n            connection.StreamsHandler = StreamsHandler;\n        }\n\n        connection.onleave = function(userid) {};\n\n        connection.invokeSelectFileDialog = function(callback) {\n            var selector = new FileSelector();\n            selector.accept = '*.*';\n            selector.selectSingleFile(callback);\n        };\n\n        connection.onmute = function(e) {\n            if (!e || !e.mediaElement) {\n                return;\n            }\n\n            if (e.muteType === 'both' || e.muteType === 'video') {\n                e.mediaElement.src = null;\n                var paused = e.mediaElement.pause();\n                if (typeof paused !== 'undefined') {\n                    paused.then(function() {\n                        e.mediaElement.poster = e.snapshot || 'https://cdn.webrtc-experiment.com/images/muted.png';\n                    });\n                } else {\n                    e.mediaElement.poster = e.snapshot || 'https://cdn.webrtc-experiment.com/images/muted.png';\n                }\n            } else if (e.muteType === 'audio') {\n                e.mediaElement.muted = true;\n            }\n        };\n\n        connection.onunmute = function(e) {\n            if (!e || !e.mediaElement || !e.stream) {\n                return;\n            }\n\n            if (e.unmuteType === 'both' || e.unmuteType === 'video') {\n                e.mediaElement.poster = null;\n                e.mediaElement.srcObject = e.stream;\n                e.mediaElement.play();\n            } else if (e.unmuteType === 'audio') {\n                e.mediaElement.muted = false;\n            }\n        };\n\n        connection.onExtraDataUpdated = function(event) {\n            event.status = 'online';\n            connection.onUserStatusChanged(event, true);\n        };\n\n        connection.getAllParticipants = function(sender) {\n            return connection.peers.getAllParticipants(sender);\n        };\n\n        if (typeof StreamsHandler !== 'undefined') {\n            StreamsHandler.onSyncNeeded = function(streamid, action, type) {\n                connection.peers.getAllParticipants().forEach(function(participant) {\n                    mPeer.onNegotiationNeeded({\n                        streamid: streamid,\n                        action: action,\n                        streamSyncNeeded: true,\n                        type: type || 'both'\n                    }, participant);\n                });\n            };\n        }\n\n        connection.connectSocket = function(callback) {\n            connectSocket(callback);\n        };\n\n        connection.closeSocket = function() {\n            try {\n                io.sockets = {};\n            } catch (e) {};\n\n            if (!connection.socket) return;\n\n            if (typeof connection.socket.disconnect === 'function') {\n                connection.socket.disconnect();\n            }\n\n            if (typeof connection.socket.resetProps === 'function') {\n                connection.socket.resetProps();\n            }\n\n            connection.socket = null;\n        };\n\n        connection.getSocket = function(callback) {\n            if (!callback && connection.enableLogs) {\n                console.warn('getSocket.callback paramter is required.');\n            }\n\n            callback = callback || function() {};\n\n            if (!connection.socket) {\n                connectSocket(function() {\n                    callback(connection.socket);\n                });\n            } else {\n                callback(connection.socket);\n            }\n\n            return connection.socket; // callback is preferred over return-statement\n        };\n\n        connection.getRemoteStreams = mPeer.getRemoteStreams;\n\n        var skipStreams = ['selectFirst', 'selectAll', 'forEach'];\n\n        connection.streamEvents = {\n            selectFirst: function(options) {\n                return connection.streamEvents.selectAll(options)[0];\n            },\n            selectAll: function(options) {\n                if (!options) {\n                    // default will always be all streams\n                    options = {\n                        local: true,\n                        remote: true,\n                        isScreen: true,\n                        isAudio: true,\n                        isVideo: true\n                    };\n                }\n\n                if (options == 'local') {\n                    options = {\n                        local: true\n                    };\n                }\n\n                if (options == 'remote') {\n                    options = {\n                        remote: true\n                    };\n                }\n\n                if (options == 'screen') {\n                    options = {\n                        isScreen: true\n                    };\n                }\n\n                if (options == 'audio') {\n                    options = {\n                        isAudio: true\n                    };\n                }\n\n                if (options == 'video') {\n                    options = {\n                        isVideo: true\n                    };\n                }\n\n                var streams = [];\n                Object.keys(connection.streamEvents).forEach(function(key) {\n                    var event = connection.streamEvents[key];\n\n                    if (skipStreams.indexOf(key) !== -1) return;\n                    var ignore = true;\n\n                    if (options.local && event.type === 'local') {\n                        ignore = false;\n                    }\n\n                    if (options.remote && event.type === 'remote') {\n                        ignore = false;\n                    }\n\n                    if (options.isScreen && event.stream.isScreen) {\n                        ignore = false;\n                    }\n\n                    if (options.isVideo && event.stream.isVideo) {\n                        ignore = false;\n                    }\n\n                    if (options.isAudio && event.stream.isAudio) {\n                        ignore = false;\n                    }\n\n                    if (options.userid && event.userid === options.userid) {\n                        ignore = false;\n                    }\n\n                    if (ignore === false) {\n                        streams.push(event);\n                    }\n                });\n\n                return streams;\n            }\n        };\n\n        connection.socketURL = '/'; // generated via config.json\n        connection.socketMessageEvent = 'RTCMultiConnection-Message'; // generated via config.json\n        connection.socketCustomEvent = 'RTCMultiConnection-Custom-Message'; // generated via config.json\n        connection.DetectRTC = DetectRTC;\n\n        connection.setCustomSocketEvent = function(customEvent) {\n            if (customEvent) {\n                connection.socketCustomEvent = customEvent;\n            }\n\n            if (!connection.socket) {\n                return;\n            }\n\n            connection.socket.emit('set-custom-socket-event-listener', connection.socketCustomEvent);\n        };\n\n        connection.getNumberOfBroadcastViewers = function(broadcastId, callback) {\n            if (!connection.socket || !broadcastId || !callback) return;\n\n            connection.socket.emit('get-number-of-users-in-specific-broadcast', broadcastId, callback);\n        };\n\n        connection.onNumberOfBroadcastViewersUpdated = function(event) {\n            if (!connection.enableLogs || !connection.isInitiator) return;\n            console.info('Number of broadcast (', event.broadcastId, ') viewers', event.numberOfBroadcastViewers);\n        };\n\n        connection.onUserStatusChanged = function(event, dontWriteLogs) {\n            if (!!connection.enableLogs && !dontWriteLogs) {\n                console.info(event.userid, event.status);\n            }\n        };\n\n        connection.getUserMediaHandler = getUserMediaHandler;\n        connection.multiPeersHandler = mPeer;\n        connection.enableLogs = true;\n        connection.setCustomSocketHandler = function(customSocketHandler) {\n            if (typeof SocketConnection !== 'undefined') {\n                SocketConnection = customSocketHandler;\n            }\n        };\n\n        // default value should be 15k because [old]Firefox's receiving limit is 16k!\n        // however 64k works chrome-to-chrome\n        connection.chunkSize = 40 * 1000;\n\n        connection.maxParticipantsAllowed = 1000;\n\n        // eject or leave single user\n        connection.disconnectWith = mPeer.disconnectWith;\n\n        // check if room exist on server\n        // we will pass roomid to the server and wait for callback (i.e. server's response)\n        connection.checkPresence = function(roomid, callback) {\n            roomid = roomid || connection.sessionid;\n\n            if (SocketConnection.name === 'SSEConnection') {\n                SSEConnection.checkPresence(roomid, function(isRoomExist, _roomid, extra) {\n                    if (!connection.socket) {\n                        if (!isRoomExist) {\n                            connection.userid = _roomid;\n                        }\n\n                        connection.connectSocket(function() {\n                            callback(isRoomExist, _roomid, extra);\n                        });\n                        return;\n                    }\n                    callback(isRoomExist, _roomid);\n                });\n                return;\n            }\n\n            if (!connection.socket) {\n                connection.connectSocket(function() {\n                    connection.checkPresence(roomid, callback);\n                });\n                return;\n            }\n\n            connection.socket.emit('check-presence', roomid + '', function(isRoomExist, _roomid, extra) {\n                if (connection.enableLogs) {\n                    console.log('checkPresence.isRoomExist: ', isRoomExist, ' roomid: ', _roomid);\n                }\n                callback(isRoomExist, _roomid, extra);\n            });\n        };\n\n        connection.onReadyForOffer = function(remoteUserId, userPreferences) {\n            connection.multiPeersHandler.createNewPeer(remoteUserId, userPreferences);\n        };\n\n        connection.setUserPreferences = function(userPreferences) {\n            if (connection.dontAttachStream) {\n                userPreferences.dontAttachLocalStream = true;\n            }\n\n            if (connection.dontGetRemoteStream) {\n                userPreferences.dontGetRemoteStream = true;\n            }\n\n            return userPreferences;\n        };\n\n        connection.updateExtraData = function() {\n            connection.socket.emit('extra-data-updated', connection.extra);\n        };\n\n        connection.enableScalableBroadcast = false;\n        connection.maxRelayLimitPerUser = 3; // each broadcast should serve only 3 users\n\n        connection.dontCaptureUserMedia = false;\n        connection.dontAttachStream = false;\n        connection.dontGetRemoteStream = false;\n\n        connection.onReConnecting = function(event) {\n            if (connection.enableLogs) {\n                console.info('ReConnecting with', event.userid, '...');\n            }\n        };\n\n        connection.beforeAddingStream = function(stream) {\n            return stream;\n        };\n\n        connection.beforeRemovingStream = function(stream) {\n            return stream;\n        };\n\n        if (typeof isChromeExtensionAvailable !== 'undefined') {\n            connection.checkIfChromeExtensionAvailable = isChromeExtensionAvailable;\n        }\n\n        if (typeof isFirefoxExtensionAvailable !== 'undefined') {\n            connection.checkIfChromeExtensionAvailable = isFirefoxExtensionAvailable;\n        }\n\n        if (typeof getChromeExtensionStatus !== 'undefined') {\n            connection.getChromeExtensionStatus = getChromeExtensionStatus;\n        }\n\n        connection.getScreenConstraints = function(callback, audioPlusTab) {\n            if (isAudioPlusTab(connection, audioPlusTab)) {\n                audioPlusTab = true;\n            }\n\n            getScreenConstraints(function(error, screen_constraints) {\n                if (!error) {\n                    screen_constraints = connection.modifyScreenConstraints(screen_constraints);\n                    callback(error, screen_constraints);\n                }\n            }, audioPlusTab);\n        };\n\n        connection.modifyScreenConstraints = function(screen_constraints) {\n            return screen_constraints;\n        };\n\n        connection.onPeerStateChanged = function(state) {\n            if (connection.enableLogs) {\n                if (state.iceConnectionState.search(/closed|failed/gi) !== -1) {\n                    console.error('Peer connection is closed between you & ', state.userid, state.extra, 'state:', state.iceConnectionState);\n                }\n            }\n        };\n\n        connection.isOnline = true;\n\n        listenEventHandler('online', function() {\n            connection.isOnline = true;\n        });\n\n        listenEventHandler('offline', function() {\n            connection.isOnline = false;\n        });\n\n        connection.isLowBandwidth = false;\n        if (navigator && navigator.connection && navigator.connection.type) {\n            connection.isLowBandwidth = navigator.connection.type.toString().toLowerCase().search(/wifi|cell/g) !== -1;\n            if (connection.isLowBandwidth) {\n                connection.bandwidth = {\n                    audio: false,\n                    video: false,\n                    screen: false\n                };\n\n                if (connection.mediaConstraints.audio && connection.mediaConstraints.audio.optional && connection.mediaConstraints.audio.optional.length) {\n                    var newArray = [];\n                    connection.mediaConstraints.audio.optional.forEach(function(opt) {\n                        if (typeof opt.bandwidth === 'undefined') {\n                            newArray.push(opt);\n                        }\n                    });\n                    connection.mediaConstraints.audio.optional = newArray;\n                }\n\n                if (connection.mediaConstraints.video && connection.mediaConstraints.video.optional && connection.mediaConstraints.video.optional.length) {\n                    var newArray = [];\n                    connection.mediaConstraints.video.optional.forEach(function(opt) {\n                        if (typeof opt.bandwidth === 'undefined') {\n                            newArray.push(opt);\n                        }\n                    });\n                    connection.mediaConstraints.video.optional = newArray;\n                }\n            }\n        }\n\n        connection.getExtraData = function(remoteUserId, callback) {\n            if (!remoteUserId) throw 'remoteUserId is required.';\n\n            if (typeof callback === 'function') {\n                connection.socket.emit('get-remote-user-extra-data', remoteUserId, function(extra, remoteUserId, error) {\n                    callback(extra, remoteUserId, error);\n                });\n                return;\n            }\n\n            if (!connection.peers[remoteUserId]) {\n                if (connection.peersBackup[remoteUserId]) {\n                    return connection.peersBackup[remoteUserId].extra;\n                }\n                return {};\n            }\n\n            return connection.peers[remoteUserId].extra;\n        };\n\n        if (!!forceOptions.autoOpenOrJoin) {\n            connection.openOrJoin(connection.sessionid);\n        }\n\n        connection.onUserIdAlreadyTaken = function(useridAlreadyTaken, yourNewUserId) {\n            // via #683\n            connection.close();\n            connection.closeSocket();\n\n            connection.isInitiator = false;\n            connection.userid = connection.token();\n\n            connection.join(connection.sessionid);\n\n            if (connection.enableLogs) {\n                console.warn('Userid already taken.', useridAlreadyTaken, 'Your new userid:', connection.userid);\n            }\n        };\n\n        connection.trickleIce = true;\n        connection.version = '3.6.8';\n\n        connection.onSettingLocalDescription = function(event) {\n            if (connection.enableLogs) {\n                console.info('Set local description for remote user', event.userid);\n            }\n        };\n\n        connection.resetScreen = function() {\n            sourceId = null;\n            if (DetectRTC && DetectRTC.screen) {\n                delete DetectRTC.screen.sourceId;\n            }\n\n            currentUserMediaRequest = {\n                streams: [],\n                mutex: false,\n                queueRequests: []\n            };\n        };\n\n        // if disabled, \"event.mediaElement\" for \"onstream\" will be NULL\n        connection.autoCreateMediaElement = true;\n\n        // set password\n        connection.password = null;\n\n        // set password\n        connection.setPassword = function(password, callback) {\n            callback = callback || function() {};\n            if (connection.socket) {\n                connection.socket.emit('set-password', password, callback);\n            } else {\n                connection.password = password;\n                callback(true, connection.sessionid, null);\n            }\n        };\n\n        connection.onSocketDisconnect = function(event) {\n            if (connection.enableLogs) {\n                console.warn('socket.io connection is closed');\n            }\n        };\n\n        connection.onSocketError = function(event) {\n            if (connection.enableLogs) {\n                console.warn('socket.io connection is failed');\n            }\n        };\n\n        // error messages\n        connection.errors = {\n            ROOM_NOT_AVAILABLE: 'Room not available',\n            INVALID_PASSWORD: 'Invalid password',\n            USERID_NOT_AVAILABLE: 'User ID does not exist',\n            ROOM_PERMISSION_DENIED: 'Room permission denied',\n            ROOM_FULL: 'Room full',\n            DID_NOT_JOIN_ANY_ROOM: 'Did not join any room yet',\n            INVALID_SOCKET: 'Invalid socket',\n            PUBLIC_IDENTIFIER_MISSING: 'publicRoomIdentifier is required',\n            INVALID_ADMIN_CREDENTIAL: 'Invalid username or password attempted'\n        };\n    })(this);\n\n};\n\nif (true /* && !!module.exports*/ ) {\n    module.exports = exports = RTCMultiConnection;\n}\n\nif (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {\n        return RTCMultiConnection;\n    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../../usr/lib/node_modules/webpack/buildin/global.js */ \"../../../../../../usr/lib/node_modules/webpack/buildin/global.js\"), __webpack_require__(/*! ./../../../../../../../usr/lib/node_modules/webpack/node_modules/process/browser.js */ \"../../../../../../usr/lib/node_modules/webpack/node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:///./src/RTCMultiConnection.js?");

/***/ })

/******/ });